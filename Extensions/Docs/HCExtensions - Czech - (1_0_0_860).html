<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<?xml version="1.0"?><HTML lang=cs xml:lang="cs" xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>Расширения HandyCache</TITLE>
<META content="text/html; charset=UTF-8" http-equiv=Content-Type>
<META name=GENERATOR content="MSHTML 8.00.7601.17622"></HEAD>
<style type="text/css">
	body {
		background-color: #000000;
		color: #FFFFFF;
		font-family: "Trebuchet MS", Verdana, myriad pro, Arial, Helvetica, sans-serif;
		font-size: 14px;
	}
	table, th, td {
		border: 1px solid black;
		border-collapse: collapse;
		font-family: "Trebuchet MS", Verdana, myriad pro, Arial, Helvetica, sans-serif;
		font-size: 14px;
	}
	th, td {
		padding-top: 5px;
		padding-right: 15px;
		padding-left: 15px;
		padding-bottom: 5;
		border: 1px solid #999999;
	}
	a:visited, a:link {
		color: #ff3300;
	}
	a:hover, a:active {
		color: #ff9933;
	}
	pre {
		display: block;
		font-family: monospace;
		white-space: pre;
		margin: 1em 0;
		font-size: 12px;
	}
	h2 {
		color: #ff3300;
		font-family: "Trebuchet MS", Verdana, myriad pro, Arial, Helvetica, sans-serif;
		font-size: 24px;
	}
	h3 {
		color: #ff3300;
		font-family: "Trebuchet MS", Verdana, myriad pro, Arial, Helvetica, sans-serif;
		font-size: 18px;
	}
</style>
<BODY>
<H2 align=center><U>Rozšíření HandyCache</U></H2>
<P>Rozšíření je speciálně uspořádaný skript v jazyku <EM>lua.</EM></P>
<P>Chcete-li začít používat rozšíření v HandyCache, musíte ve složce HandyCache mít soubor knihovny <EM>lua5.x.dll.</EM></P>
<P>Na začátku rozšíření je záhlaví. Hlavička má následující strukturu:</P>
<PRE>--[[&nbsp;&lt;HCEXTENSION&gt;
@hodnota    pole
@hodnota    pole
@hodnota    pole
..
@hodnota    pole
&lt;/HCEXTENSION&gt; ]]
</PRE>
<H3 align=center>Políčka záhlaví rozšíření</H3>
<P>
<TABLE border=1 cellSpacing=1 cellPadding=1 width="75%" align=center>
  <TBODY>
  <TR>
    <TD>
     <STRONG>Název (pole)</STRONG> </TD>
    <TD>
    <P align=center><STRONG>Popis (hodnota)</STRONG> </P></TD></TR>
  <TR>
    <TD><STRONG>name</STRONG></TD>
    <TD>Název rozšíření</TD></TR>
  <TR>
    <TD><STRONG>author</STRONG></TD>
    <TD>Jméno autora rozšíření</TD></TR>
  <TR>
    <TD><STRONG>homepage</STRONG></TD>
    <TD>Domovská stránka rozšíření</TD></TR>
  <TR>
    <TD><STRONG>version</STRONG></TD>
    <TD>Číslo verze rozšíření</TD></TR>
  <TR>
    <TD><STRONG>min_HC_version</STRONG></TD>
    <TD>Minimální číslo verze HandyCache, ze které lze toto rozšíření použít.</TD></TR>
  <TR>
    <TD><STRONG>description</STRONG></TD>
    <TD>Stručný popis rozšíření</TD></TR>
  <TR>
    <TD><STRONG>rule</STRONG></TD>
    <TD>Pravidlo (regulární výraz), které se použije ke kontrole adresy URL požadavku před voláním rozšíření. V záhlaví může být několik <EM>pravidel (rule)</EM>.</TD></TR>
  <TR>
    <TD><STRONG>exception</STRONG></TD>
    <TD>Výjimka (regulární výraz), která se použije ke kontrole adresy URL požadavku před voláním rozšíření. V hlavičce může být několik 
    <EM>vyjímek (exeption)</EM>.</TD></TR>
  <TR>
    <TD><STRONG>event</STRONG></TD>
    <TD>Název akce, pro kterou bude volání zpracováno, a pomocí lomítka název funkce určená pro zpracování této události. V záhlaví může být několik polí 
  <EM>událostí (event)</EM>.</TD></TR></TBODY></TABLE></P>
<P></P>
<H3 align=center>Příklad záhlaví rozšíření</H3>
<PRE>--[[&nbsp;&lt;HCEXTENSION&gt;
@name            Save or block 403 and 404
@author          DenZzz
@homepage        http://save_and_block.com
@version         0.01
@min_HC_version  1.0.0.193
@description     Сохраняет или блокирует ответы 403 и 404
@exception       _rtsi?_|rts_chart_ru|informer\.rts\.ru/|aton-line\.ru/.*index\.gif
@exception       ^http://[^/]*rambler\.ru/|^http://192\.168\.\d+\.
@event           AnswerHeaderReceived/answer
&lt;/HCEXTENSION&gt; ]]
</PRE>
<P align=left>Záhlaví je následováno funkcemi obsluhy událostí, stejně jako funkce volané od těchto manipulátorů. Pokud dojde v HandyCache k události, ke které je registrován psovod, je volána odpovídající funkce.</P>
<H3 align=center>Seznam zpracovaných událostí</H3>
<P align=left>
<TABLE border=1 cellSpacing=1 cellPadding=1 width="75%" align=center>
  <TBODY>
  <TR>
    <TD>
      <P align=center><STRONG>Událost</STRONG></P></TD>
    <TD>
    <P align=center><STRONG>Podmínky</STRONG></P></TD></TR>
  <TR>
    <TD><STRONG>Init</STRONG></TD>
    <TD>Vyskytuje se při načítání rozšíření během spuštění HandyCache a kdy stisknutím tlačítka <EM> Znovu načíst rozšíření </EM> na kartě <EM> Nastavení/Rozšíření</EM>. Při načítání rozšíření textového souboru rozšíření je uloženo v paměti. Proto pokud došlo k změně souboru rozšíření, musíte vybrat rozšíření v seznamu a kliknout na tlačítko <EM> Znovu načíst rozšíření.</EM></TD></TR>
  <TR>
    <TD><STRONG>Options</STRONG></TD>
    <TD>Vyskytuje se při klepnutí na tlačítko 
    <EM>Nastavení/Rozšíření.</EM> </TD></TR>
  <TR>
    <TD><STRONG>Timer1s</STRONG></TD>
    <TD>Vyskytuje se jednou za sekundu.</TD></TR>
  <TR>
    <TD><STRONG>Timer1m</STRONG></TD>
    <TD>Vyskytuje se jednou za minutu.</TD></TR>
  <TR>
    <TD><STRONG>URLToFileNameConverting</STRONG></TD>
    <TD>Vyskytuje se, když chcete převést adresu URL na název souboru v mezipaměti.</TD></TR>
  <TR>
    <TD><STRONG>BeforeViewInMonitor</STRONG></TD>
    <TD>Vyskytuje se před vytvořením nové řádky na monitoru.</TD></TR>
  <TR>
    <TD><STRONG>BeforeAuthorization</STRONG></TD>
    <TD>Vyskytuje se při obdržení požadavku od klienta a rozhoduje o tom zda žádost bude zpracována nebo zamítnuta.</TD></TR>
  <TR>
    <TD><STRONG>RequestHeaderReceived</STRONG></TD>
    <TD>Vyskytuje se, když je od klienta přijata hlavička požadavku.</TD></TR>
  <TR>
    <TD><STRONG>BeforeRequestHeaderSend</STRONG></TD>
    <TD>Vyskytuje se, když je hlavička požadavku připravena k odeslání na server.</TD></TR>
  <TR>
    <TD><STRONG>BeforeRequestBodySend</STRONG></TD>
    <TD>Vyskytuje se, když je přijata jiná data pro odeslání na server pomocí metody POST. </TD></TR>
  <TR>
    <TD><STRONG>AnswerHeaderReceived</STRONG></TD>
    <TD>Vyskytuje se, když je ze serveru odebráno záhlaví odpovědi.</TD></TR>
  <TR>
    <TD><STRONG>BeforeAnswerHeaderSend</STRONG></TD>
    <TD>Vyskytne-li se záhlaví odpovědi připraveno k odeslání klientovi. Záhlaví lze získat ze serveru nebo z vlastního systému HandyCache.</TD></TR>
  <TR>
    <TD><STRONG>BeforeAnswerBodySend</STRONG></TD>
    <TD>Vyskytuje se, když je přijata další data pro odeslání klientovi. Data mohou být získána ze serveru nebo odebrána z mezipaměti. Pokud jsou data zabalena, jsou před přenosem do obsluhy vybalena.</TD></TR>
  <TR>
    <TD><STRONG>Destroy</STRONG></TD>
    <TD>Objeví se po dokončení rozšíření (když je rozšíření odstraněno tlačítkem Odebrat rozšíření, když je přípona znovu spuštěna tlačítkem Rozšíření znovu, když je HandyCache zavřeno).</TD></TR></TBODY></TABLE></P>
<P align=left>Před voláním funkcí rozšíření vytvoří HandyCache v 
<EM>lua</EM>-automaticky dvě tabulky: <EM>hc</EM> a <EM>re</EM>. První (<EM>hc</EM>) obsahuje proměnné a funkce, které umožňují získávat informace o hodnotách interních proměnných HandyCache a měnit některé z nich. Druhý (<EM>re</EM>) obsahuje funkce, které umožňují použití rozšíření v knihovnách regulárních výrazů <EM>PCRE.</EM> </P>
<P>
<P></P>
<P></P>
<H3 align=center>Proměnné hc tabulky jsou k dispozici v těchto rozšířeních</H3>
<TABLE border=1 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=center>
      <P><B>Jméno</B></P></TD>
    <TD align=center><STRONG>Možné akce</STRONG></TD>
    <TD align=center>
      <P><B>Události</B></P></TD>
    <TD align=center>
      <P><B>Platné hodnoty</B></P></TD>
    <TD align=center>
    <P><B>Popis</B></P></TD></TR>
  <TR>
    <TD><STRONG>ver</STRONG></TD>
    <TD>čtení</TD>
    <TD>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend, Destroy</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Řetězec obsahující verzi HandyCache, například &quot;Verze 1.00 RC3 (1.0.0.250)&quot;</TD></TR>
  <TR>
    <TD><STRONG>version_number</STRONG></TD>
    <TD>čtení</TD>
    <TD>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend, Destroy</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Řetězec obsahující verzi HandyCache, například &quot;Verze 1.00 RC3 (1.0.0.250)&quot;</TD></TR>
  <TR>
    <TD><STRONG>language_id</STRONG></TD>
    <TD>čtení</TD>
    <TD>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend, Destroy</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Identifikátor jazyka používaného v uživatelském rozhraní. Seznam identifikátorů lze najít  
    <A href="https://support.microsoft.com/en-us/kb/221435">zde</A>.</TD></TR>
  <TR>
    <TD><STRONG>script_name</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>BeforeAuthorization,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend, Destroy </P></TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Cesta k aktuálnímu souboru rozšíření.</TD></TR>
  <TR>
    <TD><STRONG>event</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>BeforeAuthorization,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySen, Destroy&nbsp; </P></TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje název zpracovávané události.</TD></TR>
  <TR>
    <TD><STRONG>ini_path</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerBodySend, Destroy 
      </P></TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje cestu ke složce s konfiguračními soubory.</TD></TR>
  <TR>
    <TD><STRONG>exe_path</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerBodySend, Destroy 
      </P></TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje cestu ke složce kde je HandyCache.exe.</TD></TR>
  <TR>
    <TD><STRONG>cache_path</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerBodySend, Destroy 
      </P></TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje cestu ke složce mezipaměti.</TD></TR>
  <TR>
    <TD><STRONG>listening_port</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, URLToFileNameConverting, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerBodySend, Destroy 
      </P></TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje číslo portu k HandyCache</TD></TR>
  <TR>
    <TD><STRONG>client_connected</STRONG></TD>
    <TD>čtení</TD>
    <TD>BeforeViewInMonitor, RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend</TD>
    <TD>true, false</TD>
    <TD><p>Dává hodnotu:<br>
      <EM>true</EM> - pokud existuje spojení s klientem<br> 
    <EM>false</EM> - pokud je spojení s klientem narušeno</p></TD></TR>
  <TR >
    <TD ><STRONG>connection_index</STRONG></TD>
    <TD >čtení</TD>
    <TD >URLToFileNameConverting, BeforeViewInMonitor, 
      RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD >&lt;číslo&gt;</TD>
    <TD >Získá počet připojení pod kterým   rozšíření běží (není třeba zaměňovat číslo řádku)</TD></TR>
  <TR>
    <TD><STRONG>url</STRONG></TD>
    <TD>čtení</TD>
    <TD>URLToFileNameConverting, BeforeViewInMonitor,<BR>BeforeAuthorization,<BR>RequestHeaderReceived, 
      BeforeRequestHeaderSend, BeforeRequestBodySend, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>V souladu s RFC 2616 č.3.2.2</TD>
    <TD>Požadavek URL</TD></TR>
  <TR>
    <TD><STRONG>method</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>V souladu s RFC 2616 č.9</TD>
    <TD>Metoda použitá v žádosti</TD></TR>
  <TR>
    <TD><STRONG>is_https</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend</TD>
    <TD>true, false</TD>
    <TD>Platí, pokud je aktuální požadavek přenášen prostřednictvím protokolu https.</TD></TR>
  <TR>
    <TD>
      <STRONG>request_ims</STRONG></TD>
    <TD>
      čtení</TD>
    <TD>
      BeforeRequestHeaderSend, BeforeRequestBodySend, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>
      &lt;číslo&gt;</TD>
    <TD>
    Greenwichův průměrný čas v číselném zobrazení, získaný z pole záhlaví žádosti If-Modified-Since. Pokud nebyly v záhlaví požadavku klienta žádná pole If-Modified-Since, hodnota proměnné je nula.</TD></TR>
  <TR>
    <TD>
      <STRONG>hc_ims</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Greenwich Mean Time v numerické reprezentaci přidán do pole záhlaví požadavku If-Modified-Since HandyCache s možností Add If-Modified-Since povolena v případě, že je soubor v mezipaměti. Pokud HandyCache nepřidával hodnotu do pole If-Modified-Since, hodnota proměnné je nula.</TD></TR>
  <TR>
    <TD><STRONG>ignore_traffic</STRONG></TD>
    <TD>čtení, zápis (только в обработчиках BeforeViewInMonitor, 
      RequestHeaderReceived)</TD>
    <TD>URLToFileNameConverting, BeforeViewInMonitor, RequestHeaderReceived, 
      BeforeRequestHeaderSend, BeforeRequestBodySend, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>
    <P>Přidáním určitých znaků do tohoto řádku můžete zakázat účtování určitého typu provozu pro aktuální požadavek. Chcete-li zabránit účtování provozu přicházejícího z internetu, musíte přidat latinský znak &quot;i&quot; nebo &quot;Cyrillic&quot; a &quot;(malá nebo velká písmena). Chcete-li zakázat účtování provozu z mezipaměti, musíte přidat latinský znak &quot;c&quot; nebo &quot;cyrilský&quot; na &quot;. Chcete-li zakázat účtování odeslané dopravy, musíte přidat latinský znak &quot;u&quot; nebo cyriliku &quot;o&quot;. Chcete-li například zakázat účtování všech typů provozu, můžete do obslužného programu události přidat řádek <i>hc.ignore_traffic='ico'</i></P></TD></TR>
  <TR>
    <TD><STRONG>use_proxy</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje parametry externího HTTP proxy serveru přiřazeného k aktuální žádosti. příklad: <EM>"192.186.55.2:8080"</EM> nebo 
      <EM>"proxy.com:8081</EM>"; pokud je této proměnné přiřazena hodnota 
    <EM>"direct"</EM>, bude žádost odeslána bez použití serveru proxy</TD></TR>
  <TR>
    <TD><STRONG>use_proxy_login</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje přihlašovací přístup externího HTTP proxy serveru přiřazeného k aktuální žádosti (základní oprávnění). příklad: <EM>"user:password"</EM> 
  </TD></TR>
  <TR>
    <TD><STRONG>use_bound_ip</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Obsahuje adresu IP síťového zařízení, pomocí něhož bude odeslána žádost. příklad: "<EM>192.186.0.2</EM>"</TD></TR>
  <TR>
    <TD><STRONG>request_header</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>BeforeViewInMonitor (только чтение), BeforeAuthorization (только чтение), RequestHeaderReceived, 
      BeforeRequestHeaderSend</TD>
    <TD>В соответствие с RFC 2616</TD>
    <TD>Obsahuje záhlaví požadavku. Pokud rozšíření změní hodnotu této proměnné, změní se záhlaví na server.</TD></TR>
  <TR>
    <TD>
      <STRONG>request_body</STRONG></TD>
    <TD>
      čtení, zápis</TD>
    <TD>
      BeforeRequestHeaderSend, BeforeRequestBodySend</TD>
    <TD>
      "&lt;řetězec&gt;"</TD>
    <TD>
      <DIV>Příklad rozšíření pro zpracování těla požadavku:</DIV>
      <DIV>&nbsp;</DIV>
      <DIV>--[[ &lt;HCExtension&gt;<BR>@name ReqBody<BR>@author mai<BR>@version 
      0.2<BR>@description Example<BR>@min_HC_version 1.0.0.310<BR>@rule 
      mmm\.ru/form/<BR>@event BeforeRequestHeaderSend/header<BR>@event 
      BeforeRequestBodySend/body<BR>&lt;/HCExtension&gt; ]]<BR></DIV>
      <DIV>&nbsp;</DIV>
      <DIV>function header()<BR>&nbsp; if hc.method == 'POST' 
      then<BR>&nbsp;&nbsp;&nbsp; local s1= re.find(hc.request_header, 
      [[[^\r]*\r\n]], 0)<BR>&nbsp;&nbsp;&nbsp; local s2= 
      re.replace(hc.request_header, [[[^\r]*\r\n]], '')<BR>&nbsp;&nbsp;&nbsp; 
      hc.request_header = s1<BR>&nbsp;&nbsp;&nbsp; hc_static['req_header']= 
      s2<BR>&nbsp; end<BR>end<BR></DIV>
      <DIV>&nbsp;</DIV>
      <DIV>function body()<BR>&nbsp; if not hc_static['req_body'] then 
      hc_static['req_body']= '' end<BR>&nbsp; hc_static['req_body']= 
      hc_static['req_body']..hc.request_body<BR>&nbsp; hc.request_body= 
      ''<BR>&nbsp; if hc.last_part then<BR>&nbsp;&nbsp;&nbsp; -- Zde jsou prováděny nezbytné kroky na žádost<BR>&nbsp;&nbsp;&nbsp; 
      -- Poté se záhlaví požadavku upraví, například se nahradí<BR>&nbsp;&nbsp;&nbsp; -- požadovat délku těla<BR>&nbsp;&nbsp;&nbsp; hc.request_body= 
      hc_static['req_header']..hc_static['req_body']<BR>&nbsp;&nbsp;&nbsp; 
      hc_static['req_header']= nil<BR>&nbsp;&nbsp;&nbsp; hc_static['req_body']= 
      nil<BR>&nbsp; end<BR>end</DIV>
      <DIV><BR>
         V obsluze hlavičky BeforeRequestHeaderSend () je první řádek požadavku odeslán na server a zbývající řádky záhlaví jsou uloženy v tabulce hc_static. V obslužném parametru BeforeRequestBodySend 
      body() prodloužení přijímá části proměnné požadavku z proměnné 
      hc.request_body a uloží je do tabulky hc_static. Když je proměnná 
      hc.last_part hodnota bude přiřazena&nbsp;<EM>true</EM>, 
      Rozšíření by mělo opravit tělo a hlavičku žádosti v souladu se záměrem autora rozšíření a odeslat je na server.</DIV></TD></TR>
  <TR>
    <TD><STRONG>cache_file_name</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, 
AnswerHeaderReceived</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Název souboru v mezipaměti odpovídající aktuálnímu dotazu (prázdný řetězec, pokud není soubor).</TD></TR>
  <TR>
    <TD><STRONG>cache_file_size</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, 
AnswerHeaderReceived</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Velikost souboru v mezipaměti (-1, pokud není soubor), minus informace o režii umístěné na konci souboru.</TD></TR>
  <TR>
    <TD><STRONG>cache_file_age</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, 
AnswerHeaderReceived</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Věk (časový interval mezi okamžikem poslední aktualizace souboru a aktuálním momentem) souboru v mezipaměti v sekundách (0, pokud není soubor).</TD></TR>
  <TR>
    <TD><STRONG>cache_file_content_type</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, 
AnswerHeaderReceived</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Typ obsahu souboru v mezipaměti (prázdný řetězec, pokud soubor není v mezipaměti, nebo nebylo možné určit jeho typ).<BR></TD></TR>
  <TR>
    <TD><STRONG>cache_file_date_now</STRONG></TD>
    <TD>zápis</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, 
AnswerHeaderReceived</TD>
    <TD>true</TD>
    <TD>Je-li tato proměnná nastavena na hodnotu true, datum změny souboru v mezipaměti je přiřazeno aktuálnímu datu.<BR></TD></TR>
  <TR>
    <TD><STRONG>user_name</STRONG></TD>
    <TD>čtení</TD>
    <TD>URLToFileNameConverting, BeforeViewInMonitor, RequestHeaderReceived, 
      BeforeRequestHeaderSend, BeforeRequestBodySend, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Jméno uživatele, který odeslal požadavek.</TD></TR>
  <TR>
    <TD><STRONG>user_ip</STRONG></TD>
    <TD>čtení</TD>
    <TD>URLToFileNameConverting, BeforeViewInMonitor,<BR>BeforeAuthorization,<BR>RequestHeaderReceived, 
      BeforeRequestHeaderSend, BeforeRequestBodySend, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>IP počítače, ze kterého byla přijata žádost uživatele.</TD></TR>
  <TR>
    <TD><STRONG>user_from_internet</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Množství dat přijatých uživatelem z Internetu pro aktuální den.</TD></TR>
  <TR>
    <TD><STRONG>user_from_cache</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Množství dat přijatých uživatelem z mezipaměti pro aktuální den.</TD></TR>
  <TR>
    <TD><STRONG>user_to_internet</STRONG></TD>
    <TD>čtení</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Množství dat odeslaných uživatelem pro aktuální den.</TD></TR>
  <TR>
    <TD><STRONG>answer_header</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>В соответствие с RFC 2616</TD>
    <TD>Záhlaví odpovědi přijaté ze serveru nebo vytvořené rozšířením. Pokud přípona přidělila této proměnné novou hodnotu, pak bude klientovi předán upravený záhlaví. V mezipaměti odpovědí 302 je ze serveru přijat záhlaví. Hlavička generovaná rozšířením není zapsána do mezipaměti.</TD></TR>
  <TR>
    <TD><STRONG>answer_body</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>
      <P>RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</P>   
        </TD>
    <TD>"&lt;řetězec&gt;", <BR>"file=&lt;имя файла&gt;", 
      <BR>"file=URLToCache(&lt;URL&gt;)"</TD>
    <TD>
      <P>Při zpracování událostí <EM>RequestHeaderReceived, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend</EM> obsahuje subjekt odpovědí generovaný rozšířením. Pokud je této proměnné přiřazena hodnota, obsah této proměnné bude předán klientovi jako tělo odezvy. Tělo odezvy přijaté ze serveru je zapsáno do mezipaměti. Tělo odpovědí generované rozšířením není zapsáno do mezipaměti. Tuto proměnnou lze namísto samotného subjektu odpovědi přiřadit i název souboru, který bude použit jako tělo odezvy (<EM>"file=c:\abc\qwerty.html"</EM>), nebo URL 
      (<EM>"file=URLToCache(http://site.ru/abc.gif)"</EM>). V druhém případě bude soubor ve vyrovnávací paměti odpovídající určené adrese URL použit jako tělo odezvy.</P>
      <P> Při zpracování události<EM> BeforeAnswerBodySend</EM> prostřednictvím této proměnné prodloužení přijme další část dat pro zpracování. Ve stejné variabilní prodloužení zapíše výsledek zpracování.</P></TD></TR>
  <TR>
    <TD><STRONG>last_part</STRONG></TD>
    <TD>čtení</TD>
    <TD>BeforeAnswerBodySend</TD>
    <TD>true, false</TD>
    <TD>Platí tehdy, když je přípona naposledy vyzvána k zpracování aktuální žádosti.</TD></TR>
  <TR>
    <TD><STRONG>action</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>BeforeAuthorization,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, AnswerHeaderReceived</TD>
    <TD>
      <U>Для BeforeAuthorization:</U><BR>
      если присвоить имя пользователя из списка пользователей (пользователь должен быть разрешен), 
      то запрос будет обработан
      <HR> 
      <U>Для RequestHeaderReceived и BeforeRequestHeaderSend:</U><BR>
      можно использовать все допустимые значения 
      <HR>
      <U>Для AnswerHeaderReceived:</U><BR>"stop", <BR>"dont_update", <BR>"save", 
      <BR>"dont_save"</TD>
    <TD>Akce, která by měla vykonávat HC: 
      <UL>
        <LI><EM>"stop"</EM> - blokovat stahování; 
        <LI><EM>"dont_update"</EM> - neaktualizujte soubor (deaktivujte z mezipaměti). 
        <LI><EM>"only_from_cache"</EM> - pokud je soubor v mezipaměti, pak jej dáte klientovi, jinak zablokuje stahování. 
        <LI><EM>"save"</EM> - zápis do mezipaměti; 
        <LI><EM>"dont_save"</EM> - nezapisujte soubor do vyrovnávací paměti i když je seznam zapsán do mezipaměti<EM>.</EM> </LI></UL>
      Pokud na konci názvu akce umístíte znak &quot;-&quot;, bude tato akce použita pouze tehdy, pokud je pro tento požadavek aktivní odpovídající seznam. Například: akce 
      <EM>"stop-"</EM> bude blokovat stahování pouze v případě <EM>Černý seznam</EM> 
      nebylo nekontrolováno <EM>Povolit</EM>, klávesová zkratka nebo <EM>Bílý seznam.</EM> </TD></TR>
  <TR>
    <TD><STRONG>extensions_on</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, BeforeRequestHeaderSend, BeforeRequestBodySend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>true, false</TD>
    <TD>Pokud přiřadíte tuto hodnotu proměnné <EM>false</EM>, pak pro aktuální požadavek na všechny další zpracovatele událostí již nebudou volány.</TD></TR>
  <TR>
    <TD><STRONG>read_from_cache_on</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived</TD>
    <TD>true, false</TD>
    <TD>Присвоение <EM>false</EM> запрещает чтение из кэша для текущего 
      запроса.</TD></TR>
  <TR>
    <TD><STRONG>add_ims_on</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived</TD>
    <TD>true, false</TD>
    <TD>Přiřazení hodnoty této proměnné řídí volbu Přidat if-Modified-Since, pokud je v mezipaměti soubor pro aktuální požadavek.</TD></TR>
  <TR>
    <TD><STRONG>offline_disable</STRONG></TD>
    <TD>zápis</TD>
    <TD>RequestHeaderReceived</TD>
    <TD>true, false</TD>
    <TD>Přiřazení této proměnné na <EM>true</EM> zakáže režim offline pro aktuální požadavek.</TD></TR>
  <TR>
    <TD><STRONG>ramcache_disable</STRONG></TD>
    <TD>zápis</TD>
    <TD>RequestHeaderReceived</TD>
    <TD>true, false</TD>
    <TD>Přidělení této proměnné na hodnotu <EM>true</EM> zakáže použití mezipaměti paměti RAM pro aktuální požadavek.</TD></TR>
  <TR>
    <TD><STRONG>white_mask</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>BeforeViewInMonitor, RequestHeaderReceived</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Маска <EM>Белого списка</EM> - в эту переменную можно добавить по 
      одному символу для каждого из списков, если нужно, чтобы этот список не 
      работал с данным запросом. Для обозначения списков можно использовать 
      символы: 
      <UL>
        <LI>W или Б - Белый список 
        <LI>B или Ч - Черный список 
        <LI>S или З - список Запись в кэш 
        <LI>D или Н - список Не обновлять 
        <LI>O или Т - список Только из кэша 
        <LI>R или А - список Переадресация 
        <LI>U или П - список Преобразование URL </LI></UL>Символы могут быть 
      строчные или заглавные. Например, для выключения <EM>Черного списка</EM>, 
      списка <EM>Только из кэша</EM> и списка <EM>Преобразование URL</EM> 
      значение переменной может быть такое: hc.white_mask="ЧТu". Запрет начинает 
      действовать немедленно после присвоения значенияпеременной.</TD></TR>
  <TR>
    <TD><STRONG>file_speed_limit</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, AnswerHeaderReceived</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Если этой переменной присвоить значение больше 0, то это значение будет использоваться как лимит скорости (в 
      байтах в секунду) для загрузки данного файла. Присвоение переменной значения 0 
      снимает ограничение.</TD></TR>
  <TR>
    <TD><STRONG>user_speed_limit</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, AnswerHeaderReceived</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Если этой переменной присвоить значение больше 0, то это значение 
      будет использоваться как лимит скорости (в байтах в секунду) для данного 
      пользователя до задания другого значения или перезапуска HandyCache. 
      <EM>hc.user_speed_limit</EM>=0 снимает ограничения скорости для данного 
      пользователя.</TD></TR>
  <TR>
    <TD><STRONG>freezed_disconnection_time</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>RequestHeaderReceived, AnswerHeaderReceived</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Если этой переменной присвоить значение больше 0, то это значение 
      будет использоваться как интервал до разрыва застывшего соединения  
      (в секундах) для данного соединения. 
     </TD></TR>
  <TR>
    <TD><STRONG>dont_load_large_files_on</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend </P></TD>
    <TD>true, false</TD>
    <TD>Принимает текущее состояние опции Не загружать большие файлы.</TD></TR>
  <TR>
    <TD><STRONG>speed_limit_on</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend </P></TD>
    <TD>true, false</TD>
    <TD>Принимает текущее состояние опции Ограничить скорость загрузки.</TD></TR>
  <TR>
    <TD><STRONG>offline_on</STRONG></TD>
    <TD>čtení</TD>
    <TD>
      <P>Init, Options, Timer1s, Timer1m, 
      BeforeViewInMonitor,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      AnswerHeaderReceived, BeforeAnswerHeaderSend, BeforeAnswerBodySend </P></TD>
    <TD>true, false</TD>
    <TD>Принимает текущее состояние опции Автономный режим.</TD></TR>
  <TR>
    <TD><STRONG>monitor_index</STRONG></TD>
    <TD>čtení</TD>
    <TD>BeforeViewInMonitor,<BR>RequestHeaderReceived, 
      BeforeRequestHeaderSend, BeforeRequestBodySend, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Принимает значение номера строки в мониторе, соответствующей текущему 
      запросу.</TD></TR>
  <TR>
    <TD><STRONG>hide_in_active_list</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>BeforeViewInMonitor</TD>
    <TD>true, false</TD>
    <TD>Если этой переменной присвоено значение true, то строка в в списке 
      активных запросов, соответсвующая текущему запросу будет спрятана.</TD></TR>
  <TR>
    <TD><STRONG>hide_in_monitor</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>BeforeViewInMonitor, RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend</TD>
    <TD>true, false</TD>
    <TD>Если этой переменной присвоено значение true, то строка в мониторе, 
      соответсвующая текущему запросу будет спрятана.</TD></TR>
  <TR>
    <TD><STRONG>monitor_text_color</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>BeforeViewInMonitor,<BR>BeforeAuthorization,<BR>RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend</TD>
    <TD>&lt;číslo&gt;</TD>
    <TD>Задает цвет текста в строке монитора. Если уровни основных цветовых 
      составляющих R, G и B, то цвет задается числом R+G*256+B*256*256. R, G и B 
      могут принимать значения от 0 до 255.</TD></TR>
  <TR>
    <TD><STRONG>monitor_parent_url</STRONG></TD>
    <TD>чтение, запись (только в обработчике BeforeViewInMonitor)</TD>
    <TD>BeforeViewInMonitor, RequestHeaderReceived, BeforeRequestHeaderSend, 
      BeforeRequestBodySend, AnswerHeaderReceived, BeforeAnswerHeaderSend, 
      BeforeAnswerBodySend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Задает URL строки монитора, которая будет 'родительской' для строки 
      текущего запроса. Если переменной значение не было присвоено, то при 
      чтении этой переменной выдается значение поля Referer заголовка 
  запроса.</TD></TR>
  <TR>
    <TD><STRONG>monitor_string</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>URLToFileNameConverting,<BR>BeforeAuthorization,<BR>BeforeViewInMonitor, RequestHeaderReceived, 
      BeforeRequestHeaderSend, BeforeRequestBodySend, AnswerHeaderReceived, 
      BeforeAnswerHeaderSend, BeforeAnswerBodySend</TD>
    <TD>"&lt;řetězec&gt;"</TD>
    <TD>Содержит значение, присвоенное предыдущими расширениями при обработке 
      текущего события. Расширение может присвоить свое значение этой 
      переменной. Значение этой переменной будет выведено в колонке Правила в 
      Мониторе в строке текущего запроса.<BR>
      Если навести указатель мыши на сообщение в колонке Правило, будет выведен хинт, 
      который может содержать дополнительную информацию. Ту часть сообщения, которая 
      предназначена для вывода в хинт, нужно обрамлять с двух сторон последовательностями 
      символов #~#. Например, так hc.monitor_string = hc.monitor_string .. 'Message' .. '
      #~#This is a hint#~#,' 
      </TD></TR></TBODY></TABLE>
<P></P>
<H3 align=center>Функции таблицы hc</H3>
<P></P>
<TABLE border=1 cellSpacing=2>
  <TBODY>
  <TR>
    <TD>
      <P align=center><STRONG>Имя</STRONG></P></TD>
    <TD>
      <P align=center><STRONG>Описание</STRONG></P></TD></TR>
  <TR>
    <TD><STRONG>shell_execute</STRONG></TD>
    <TD>
      <P>Функция является оберткой Windows API функции ShellExecute (аргумент 
      <EM>Operation="Open")</EM>. Подробнее смотрите <A 
      href="http://msdn.microsoft.com/en-us/library/bb762153%28VS.85%29.aspx">здесь</A>.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>File</STRONG> - </EM>имя 
      открываемого файла;<BR><EM><STRONG>Parameters</STRONG> -</EM> строка 
      параматров, которая будет послана открываемому 
      приложению;<BR><EM><STRONG>Directory</STRONG> -</EM> стандартный каталог 
      (default directory), передаваемый 
      приложению.<BR><EM><STRONG>ShowCmd</STRONG> -</EM> флаг, задающий 
      состояние окна приложения при открытии, может принимать 
      значения&nbsp;'SW_HIDE', 'SW_MAXIMIZE', 'SW_MINIMIZE', 'SW_RESTORE', 
      'SW_SHOW', 'SW_SHOWDEFAULT','SW_SHOWMAXIMIZED', 'SW_SHOWMINIMIZED', 
      'SW_SHOWMINNOACTIVE', 'SW_SHOWNA', 'SW_SHOWNOACTIVATE', 
      'SW_SHOWNORMAL'.<BR><EM><STRONG>Wait</STRONG> -</EM> принимает значение <EM>true</EM> или 
      <EM>false</EM>; если присвоено значение <EM>true</EM>, то функция будет 
      ожидать выполнения запущенной операции, в противном случае ожидания не 
      будет.</P>
      <P><U>Возвращаемое значение:</U> Возвращает строку 'OK' при успешном 
      вызове функции. В случае ошибки, возвращает сообщение об ошибке.</P>
      <P><U>Пример использования:</U> <EM>hc.shell_execute('notepad.exe', 
      'stat.txt', nil, 'SW_SHOW')</EM> </P></TD></TR>
  <TR >
    <TD ><STRONG>execute_and_wait</STRONG></TD>
    <TD >
      <P>Функция запускает на выполнение программу и дожидается ее 
      завершения.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>Cmd</STRONG> - 
      </EM>имя&nbsp;программы; если нужно через пробел можно добавить аргументы 
      для вызываемой программы.</P>
      <P><U>Возвращаемое значение:</U> Код завершения запускаемой программы.</P>
      <P><U>Пример использования:</U> 
      <EM>hc.execute_and_wait('notepad.exe&nbsp;stat.txt')</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>play_sound</STRONG></TD>
    <TD>
      <P>Функция является оберткой Windows API функции PlaySound. Подробнее 
      смотрите <A 
      href="http://msdn.microsoft.com/en-us/library/ms712879.aspx">здесь</A>.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>Sound</STRONG></EM> - имя 
      wav-файла или системного события ('SystemAsterisk', 'SystemDefault', 
      'SystemExclamation', 'SystemExit', 'SystemHand', 'SystemQuestion', 
      'SystemStart', 'SystemWelcome').<BR></P>
      <P><U>Возвращаемое значение:</U> нет.</P>
      <P><U>Примеры использования:</U> 
      <BR><EM>hc.play_sound('blocked.wav')<BR>hc.play_sound('SystemExclamation')</EM> 
      </P></TD></TR>
  <TR >
    <TD ><STRONG>crc32</STRONG></TD>
    <TD >
      <P>Функция выполняет подсчет хэша crc32&nbsp;для входной строки.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>Str</STRONG> - </EM>входная 
      строка.</P>
      <P><U>Возвращаемое значение:</U> Crc32 хэш-код входной строки (число).</P>
      <P><U>Пример использования:</U> crc = <EM>hc.crc32(str_line)</EM> 
  </P></TD></TR>
  <TR>
  <TD><STRONG>compress</STRONG></TD>
    <TD>
      <P>Функция выполняет упаковку строки, используя алгоритм gzip.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>Str</STRONG> - </EM>входная 
      строка.</P>
      <P><U>Возвращаемое значение:</U> Упакованная строка.</P>
      <P><U>Пример использования:</U> gzip = 
  <EM>hc.compress(str_line)</EM></P></TD></TR>
  <TR>
  <TD><STRONG>uncompress</STRONG></TD>
    <TD>
      <P>Функция выполняет распаковку строки, используя алгоритм gzip.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>Str</STRONG> - </EM>входная 
      строка.</P>
      <P><U>Возвращаемое значение:</U> Распакованная строка.</P>
      <P><U>Пример использования:</U> out = 
  <EM>hc.uncompress(str_line)</EM></P></TD></TR>
  <TR>
  <TD><STRONG>encode_base64</STRONG></TD>
    <TD>
      <P>Функция выполняет кодирование строки в формате base64.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>Str</STRONG> - </EM>входная 
      строка.</P>
      <P><U>Возвращаемое значение:</U> Результат кодирования строки.</P>
      <P><U>Пример использования:</U> crc = 
  <EM>hc.encode_base64(str_line)</EM></P></TD></TR>
  <TD><STRONG>decode_base64</STRONG></TD>
    <TD>
      <P>Функция выполняет декодирование строки, кодированной в формате 
      base64.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>Str</STRONG> - </EM>входная 
      строка.</P>
      <P><U>Возвращаемое значение:</U> Результат декодирования строки.</P>
      <P><U>Пример использования:</U> crc = 
  <EM>hc.decode_base64(str_line)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>recode</STRONG></TD>
    <TD>
      <P>Функция выполняет преобразование одной кодировки строки в другую.</P>
      <P><U>Аргументы функции:<BR></U><EM><STRONG>Str</STRONG> -&nbsp; 
      </EM>строка для преобразования;<BR><EM><STRONG>InCP</STRONG> -</EM> 
      &nbsp;&nbsp;кодировка входной строки;<BR><EM><STRONG>OutCP</STRONG> -</EM> 
      &nbsp;кодировка выходной строки;<BR><EM><STRONG>Flags</STRONG>&nbsp;-</EM> флаги, 
      управляющие преобразованием; если этот аргумент пропущен, то используется 
      значение 0;<BR>Значения&nbsp;некоторых&nbsp;флагов:<BR>WC_COMPOSITECHECK 
      = 512<BR>WC_DISCARDNS = 16<BR>WC_SEPCHARS =       32<BR>WC_DEFAULTCHAR = 
      64<BR>Назначение флагов можно посмотреть в описании функции 
      <STRONG>WideCharToMultiByte</STRONG>, например, <A 
      href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd374130%28v=vs.85%29.aspx" 
      rel=nofollow>здесь</A>.<BR><EM><STRONG>DefaultChar</STRONG>&nbsp;-</EM>&nbsp;символ, 
      который будет помещен в строку, если в указанной кодировке символ не может 
      быть представлен;&nbsp;если аргумент пропущен, то выводится символ 
      '?'.<BR>Номера некоторых часто встречающихся кодовых 
      страниц:<BR>utf8 - 65001<BR>Cyrillic (DOS) - 866<BR>Cyrillic (iso-8859-5) 
      - 28595<BR>Cyrillic (KOI8-R) - 20866<BR>Cyrillic (windows-1251) - 
      1251<BR>Номера других кодовых страниц можно посмотреть, например, <A 
      href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd317756(v=vs.85).aspx" 
      rel=nofollow>здесь</A>.<BR>Вместе с кодировками входной и выходной строк 
      можно использовать модификаторы. Применение модификатора 100000 приводит к 
      использованию дополнительного кодирования строки в виде %XXX (см. 
      примеры). Модификатор 200000 инициирует использование puny-кода. 
      <P><U>Возвращаемое значение:</U> 
      <STRONG>Первым</STRONG> значением возвращается выходная строка 
      в&nbsp;заданной кодировке. <STRONG>Вторым</STRONG> значением является 
      <EM>true</EM> или <EM>false</EM> в зависимости от того потебовалось 
      использовать символ&nbsp;<STRONG><EM>DefaultChar</EM></STRONG>   или нет.</P>
      <P><U>Примеры использования:</U><BR><EM>local new_str= hc.recode(str, 
      20866, 1251)<BR>local x_str=                                   hc.recode('привет', 1251, 1251+100000)&nbsp; 
      -- x_str будет присвоено ''%EF%F0%E8%E2%E5%F2'<BR>local w_str= 
      hc.recode('%EF%F0%E8%E2%E5%F2', 1251+100000, 1251)&nbsp; -- w_str будет 
      присвоено 'привет'<BR>local utf8_str=                                   hc.recode('привет', 1251, 
      65001+100000)&nbsp; -- utf8_str будет присвоено 
      '%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82'<BR>local ww_str= 
      hc.recode('%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82', 65001+100000, 
      1251)&nbsp; -- ww_str будет присвоено 'привет'<BR>local puny_str= 
      hc.recode('привет', 1251, 1251+200000)&nbsp; -- puny_str будет присвоено 
      'b1agh1afp'<BR>local win_str=  hc.recode('b1agh1afp', 1251+200000, 
      1251)&nbsp; -- win_str будет присвоено 'привет'</EM> </P>
      <P><EM>local WC_COMPOSITECHECK =                                 512 --convert 
      composite to precomposed<BR>local WC_DEFAULTCHAR = 64 --replace w default 
      char<BR>local s,b = hc.recode('абвгд 12345 abcde', 1251, 28591, 
      WC_COMPOSITECHECK+WC_DEFAULTCHAR, '#') --s будет присвоено '##### 12345 
      abcde',&nbsp;а b - true</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>execute_cmd</STRONG></TD>
    <TD>
      <P>Функция выполняет команду (те же команды, что и для утилиты HCCmd).</P>
      <P><U>Аргументы функции:<BR></U><EM><STRONG>Cmd</STRONG></EM> 
      -&nbsp;команда.</P>
      <P>Список команд.<BR>'AddToWhiteList URL' - добавить в Белый список 
      <BR>'AddToBlackList URL' - добавить в Черный список 
      <BR>'AddToSaveToCacheList URL' - добавить в список Запись в кэш 
      <BR>'AddToDontUpdateList URL' - добавить в список Не обновлять 
      <BR>'AddToOnlyFromCacheList URL' - добавить в список Только из кэша 
      <BR>'ViewWindow' - показать главное окно <BR>'ViewWhiteList' - показать 
      Белый список <BR>'ViewBlackList' - показать Черный список 
      <BR>'ViewSaveToCacheList' - показать список Запись в кэш 
      <BR>'ViewDontUpdateList' - показать список Не обновлять 
      <BR>'ViewOnlyFromCacheList' - показать список Только из кэша 
      <BR>'WhiteList on|off|switch' - управление Белым списком <BR>'BlackList 
      on|off|switch' - управление Черным списком <BR>'SaveToCacheList 
      on|off|switch' - управление списком Запись в кэш <BR>'DontUpdateList 
      on|off|switch' - управление списком Не обновлять <BR>'OnlyFromCacheList 
      on|off|switch' - управление списком Только из кэша <BR>'OffLine 
      on|off|switch' - управление Автономным режимом <BR>'RedirectList 
      on|off|switch' - управление списком Переадресация <BR>'FreshFiles 
      on|off|switch' - управление опцией Не обновлять свежие файлы 
      <BR>'ReadFromCache on|off|switch' - управление чтением из кэша 
      <BR>'LoadURL' - загрузить URL в кэш <BR>'DeleteURL' - удалить URL из кэша 
      <BR>'StopURL' - остановить загрузку URL <BR>'ClearCache' - запустить 
      очистку кэша <BR>'Exit' - завершить выполнение программы 
      <BR>'URLTransformingList on|off|switch' - управление списком 
      Преобразование URL <BR>'DontLoadLargeFiles on|off|switch' - управление 
      опцией Не загружать большие файлы <BR>'SpeedLimit on|off|switch' - 
      управление опцией Ограничить скорость загрузки <BR>'MediatorServers 
      on|off|switch' - управление списком серверов-посредников <BR>'DNSCache 
      on|off|switch' - управление DNS-кэшем <BR>'ParentProxy on|off|switch' - 
      управление внешними прокси <BR>'UnconditionalProxy on|off|switch' - 
      управление безусловными прокси <BR>'ConditionalProxy on|off|switch' - 
      управление условными прокси <BR>'Statistics on|off|switch' - управление 
      ведением статистики<BR>'SelectCacheDirSet 1|2' - выбрать активный набор 
      каталогов кэша<BR>'SetMainCacheDir1 DirPath' - задать основной каталог 
      первого набора<BR>'SetMainCacheDir2 DirPath' - задать основной каталог 
      второго набора<BR>'SetROCacheDir1 DirPath' - задать каталог кэша только 
      для чтения первого набора<BR>'SetROCacheDir2 DirPath' - задать каталог 
      кэша только для чтения второго набора<BR>'SelectParentProxy 
      ProxyName' - задать текущий безусловный родительский 
      прокси<BR>'ViewExtensionsList' - показать список 
      расширений<BR>'EnableExtension ExtName' - разрешить работу 
      расширения<BR>'DisableExtension ExtName' - запретить 
      работу расширения<BR>'ReloadExtension ExtName' 
      -&nbsp;перечитать&nbsp;расширение из файла</P>
      
      <P><U>Возвращаемое значение:</U> нет.</P>
      <P><U>Примеры использования:</U> <BR><EM>hc.execute_cmd('BlackList 
      on')<BR>hc.execute_cmd('ClearCache') </EM></P></TD></TR>
  <TR>
    <TD><STRONG>send_request</STRONG></TD>
    <TD>
      <P>Функция&nbsp;отправляет&nbsp;через HandyCache http-запрос. Этот запрос 
      обрабатывается HandyCache таким же образом, как все другие запросы, 
      проходящие через него (работают все опции, списки, расширения).</P>
      <P><U>Аргументы функции:<BR></U><STRONG><EM>header&nbsp;-</EM></STRONG> 
      заголовок http-запроса;<BR><STRONG><EM>body</EM></STRONG>&nbsp;-&nbsp;тело 
      http-запроса для метода POST.<BR>
      <STRONG><EM>https_header</EM></STRONG>&nbsp;-&nbsp;заголовок для 
      формирования https-запроса к прокси-серверу.</P>
      <P><U>Возращаемое значение:</U> нет.</P>
      <P><U>Пример использования:</U><BR>
      <EM>hdr =      'GET http://mail.ru HTTP/1.0\r\nConnection: 
      close\r\n\r\n'<BR>hc.send_request(hdr)</EM><BR>
      <EM>или</EM><BR>
      <EM>hdr = 'GET http://mail.ru HTTP/1.0\r\n'..<BR>'Connection: close\r\n\r\n'<BR>https_hdr =&nbsp; 'CONNECT 
      mail.ru:443 HTTP/1.1\r\n'..<BR>'Host: mail.ru\r\n'..<BR>'Connection: 
      keep-alive\r\n\r\n'<BR>hc.send_request(hdr, '', 
      https_hdr)<BR></EM></P></TD></TR>
  <TR>
    <TD><STRONG>sleep</STRONG></TD>
    <TD>
      <P>Функция останавливает выполнение расширения на заданный интервал 
      времени.</P>
      <P><U>Аргументы функции:<BR></U><STRONG>t</STRONG>&nbsp;-&nbsp;интервал 
      времени в миллисекундах.</P>
      <P><U>Возращаемое значение:</U> нет.</P>
      <P><U>Пример использования:</U> <EM>hc.sleep(1000)</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>put_msg</STRONG></TD>
    <TD>
      <P>Функция вызывает появление на экране информационного окошка с заданным 
      сообщением.</P>
      <P><U>Аргументы функции:<BR></U><STRONG><EM>time -</EM></STRONG> если 
      первый аргумент является числом и количество аргументов больше одного, то 
      первый аргумент&nbsp;интерпретируется как время нахождения сообщения на 
      экране в секундах, может принимать значения от 1 до 20; сообщение будет 
      находиться на экране до тех пор, пока не истечет время, заданное 
      параметром <EM><STRONG>time</STRONG></EM>, или не будет вызвано на экран 
      другое сообщение; если этот аргумент не задан, то сообщение будет 
      находиться на экране 5 
      секунд;<BR><EM><STRONG>msg</STRONG></EM>&nbsp;-&nbsp;сообщение.</P>
      <P><U>Возращаемое значение:</U> нет.</P>
      <P><U>Пример использования:</U> <EM>hc.put_msg(10, 'Очистка кэша 
      запущена')</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>put_to_log</STRONG></TD>
    <TD>
      <P>Функция помещает заданное сообщение в лог программы.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>msg</STRONG></EM>&nbsp;-&nbsp;сообщение; 
      сообщение может состоять из нескольких частей, разделенных запятыми; 
      каждая из частей может быть строкой или числом;</P>
      <P><U>Возращаемое значение:</U> нет.</P>
      <P><U>Пример использования:</U> 
      <EM>hc.put_to_log('method='..hc.method)</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>get_keyboard_state</STRONG></TD>
    <TD>
      <P>Функция получает список нажатых клавиш.</P>
      <P><U>Аргументы функции:</U> нет.</P>
      <P><U>Возвращаемое значение:</U> Строка со списком нажатых 
      клавиш.<BR>Перечень имен клавиш:<BR>'VK_LBUTTON', 'VK_RBUTTON', 
      'VK_CANCEL', 'VK_MBUTTON', 'VK_XBUTTON1', 'VK_XBUTTON2','VK_BACK', 
      'VK_TAB', 'VK_CLEAR', 'VK_RETURN', 'VK_SHIFT', 'VK_CONTROL', 
      'VK_MENU','VK_PAUSE', 'VK_CAPITAL', 'VK_KANA', 'VK_JUNJA', 'VK_FINAL', 
      'VK_HANJA', 'VK_KANJI','VK_ESCAPE', 'VK_CONVERT', 'VK_NONCONVERT', 
      'VK_ACCEPT', 'VK_MODECHANGE', 'VK_SPACE','VK_PRIOR', 'VK_NEXT', 'VK_END', 
      'VK_HOME', 'VK_LEFT', 'VK_UP', 'VK_RIGHT', 'VK_DOWN','VK_SELECT', 
      'VK_PRINT', 'VK_EXECUTE', 'VK_SNAPSHOT', 'VK_INSERT', 
      'VK_DELETE','VK_HELP', 'VK_0', 'VK_1', 'VK_2', 'VK_3', 'VK_4', 'VK_5', 
      'VK_6', 'VK_7', 'VK_8', 'VK_9','VK_A', 'VK_B', 'VK_C', 'VK_D', 'VK_E', 
      'VK_F', 'VK_G', 'VK_H', 'VK_I', 'VK_J','VK_K', 'VK_L', 'VK_M', 'VK_N', 
      'VK_O', 'VK_P', 'VK_Q', 'VK_R', 'VK_S', 'VK_T','VK_U', 'VK_V', 'VK_W', 
      'VK_X', 'VK_Y', 'VK_Z', 'VK_LWIN', 'VK_RWIN', 'VK_APPS','VK_SLEEP', 
      'VK_NUMPAD0', 'VK_NUMPAD1', 'VK_NUMPAD2', 'VK_NUMPAD3', 
      'VK_NUMPAD4','VK_NUMPAD5', 'VK_NUMPAD6', 'VK_NUMPAD7', 'VK_NUMPAD8', 
      'VK_NUMPAD9', 'VK_MULTIPLY', 'VK_ADD', 'VK_SEPARATOR', 'VK_SUBTRACT', 
      'VK_DECIMAL', 'VK_DIVIDE', 'VK_F1', 'VK_F2','VK_F3', 'VK_F4', 'VK_F5', 
      'VK_F6', 'VK_F7', 'VK_F8', 'VK_F9', 'VK_F10', 'VK_F11','VK_F12', 'VK_F13', 
      'VK_F14', 'VK_F15', 'VK_F16', 'VK_F17', 'VK_F18', 'VK_F19','VK_F20', 
      'VK_F21', 'VK_F22', 'VK_F23', 'VK_F24', 'VK_NUMLOCK', 
      'VK_SCROLL','VK_LSHIFT', 'VK_RSHIFT', 'VK_LCONTROL', 'VK_RCONTROL', 
      'VK_LMENU', 'VK_RMENU','VK_BROWSER_BACK', 'VK_BROWSER_FORWARD', 
      'VK_BROWSER_REFRESH', 'VK_BROWSER_STOP','VK_BROWSER_SEARCH', 
      'VK_BROWSER_FAVORITES', 'VK_BROWSER_HOME', 
      'VK_VOLUME_MUTE','VK_VOLUME_DOWN', 'VK_VOLUME_UP', 'VK_MEDIA_NEXT_TRACK', 
      'VK_MEDIA_PREV_TRACK','VK_MEDIA_STOP', 'VK_MEDIA_PLAY_PAUSE', 
      'VK_LAUNCH_MAIL', 'VK_LAUNCH_MEDIA_SELECT','VK_LAUNCH_APP1', 
      'VK_LAUNCH_APP2', 'VK_OEM_1', 'VK_OEM_PLUS', 
      'VK_OEM_COMMA','VK_OEM_MINUS', 'VK_OEM_PERIOD', 'VK_OEM_2', 'VK_OEM_3', 
      'VK_OEM_4', 'VK_OEM_5','VK_OEM_6', 'VK_OEM_7', 'VK_OEM_8', 'VK_OEM_102', 
      'VK_PROCESSKEY', 'VK_PACKET', 'VK_ATTN', 'VK_CRSEL', 'VK_EXSEL', 
      'VK_EREOF', 'VK_PLAY', 'VK_ZOOM', 'VK_NONAME','VK_PA1', 'VK_OEM_CLEAR' 
</P>
      <P><U>Пример использования:</U><BR><EM>_,_,x = 
      string.find(hc.get_keyboard_state(), 'VK_F11')<BR>if x~=nil then ... 
      end</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>systime_to_str</STRONG></TD>
    <TD>
      <P>Функция преобразует системное время в строковое представление.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>time</STRONG> -</EM> время по 
      Гринвичу в числовом представлении;<BR><EM><STRONG>gmt</STRONG> -</EM> 
      формат представления времени, принимает значения <EM>true</EM> или 
      <EM>false</EM> (по умолчанию <EM>true</EM>). Если передано значение 
      <EM>true</EM>, то на выходе функции время будет по Гринвичу. Если передано 
      значение <EM>false</EM>, то локальное время.</P>
      <P><U>Возвращаемое значение:</U> Время в строковом представлении.</P>
      <P><U>Пример использования:</U><EM> s =                                             hc.systime_to_str(os.time(), 
      false)</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>str_to_systime</STRONG></TD>
    <TD>
      <P>Функция преобразует строковое представление времени в числовое.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>str</STRONG>&nbsp;-</EM> время 
      в формате, применяемом в http-заголовках;<BR><EM><STRONG>gmt</STRONG> 
      -</EM> формат представления времени в первом аргументе, принимает значения 
      <EM>true</EM> или <EM>false</EM> (по умолчанию <EM>true</EM>). Если 
      передано значение <EM>true</EM>, то в первом аргументе должно находиться 
      строковое представление&nbsp;времени&nbsp;по Гринвичу. Если передано 
      значение <EM>false</EM>, то в первом аргументе должно находиться строковое 
      представление локального&nbsp;времени.</P>
      <P><U>Возращаемое значение:</U> Время по Гринвичу в числовом представлении 
      (время в секундах, прошедшее после 0 часов 0 минут 1 января 1970 
года).</P>
      <P><U>Пример использования:</U><BR><EM>t1=hc.str_to_systime('Tue, 25 Nov 
      2008 02:52:14 GMT')<BR>t2=os.time() -- Текущее время по Гринвичу в 
      числовом представлении<BR>hc.put_to_log('C 25 ноября 2008 г. прошло 
      '..(t2-t1)/3600/24..' дней')</EM> </P></TD></TR>
  <TR>
    <TD><STRONG>get_host_IP</STRONG></TD>
    <TD>
      <P>Функция получает IP-адрес для заданного имени сетевого узла.</P>
      <P><U>Аргументы функции:</U><BR>
      <EM><STRONG>host</STRONG>&nbsp;-</EM>&nbsp;имя сетевого узла;<BR>
      <STRONG><EM>cache</EM></STRONG> - разрешение использования кэша 
      DNS, принимает значения <EM>true</EM> или <EM>false</EM>; если этот 
      аргумент опущен, то использование кэша разрешено.<BR>
      <EM><STRONG>timeout</STRONG>&nbsp;-</EM>&nbsp;время, отведенное на выполнение функции;<BR>
      </P>
      <P><U>Возвращаемое значение:</U> <STRONG>Первым</STRONG> значением 
      возвращается IP-адрес в виде строки; если IP-адрес не найден, то 
      <STRONG>первое</STRONG> значение равно <EM>nil</EM>;
      <STRONG>вторым</STRONG> значением функция возвращает строку - 
      сообщение; в случае удачи сообщается был ли найден адрес в кэше; в случае 
      неудачи - причина. Если истекло время на выполнение функции, функция 
      возвращает значение <EM>-1</EM>.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;ip,e=hc.get_host_IP('handycache.ru')</EM></P></TD></TR>
  <TR style="COLOR: ">
    <TD><STRONG>ssl_handling_enabled</STRONG></TD>
    <TD>
      <P>Функция сообщает разрешена обработка SSL или нет.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>url</STRONG>&nbsp;-</EM>&nbsp;запрашиваемый 
      URL;<BR><STRONG><EM>name</EM></STRONG> - имя пользователя, от которого 
      поступил запрос.</P>
      <P><U>Возвращаемое значение:</U>&nbsp;Если функция вызвана без аргументов, 
      то&nbsp;она возвращает состояние опции Обработка SSL.&nbsp;Если значения 
      аргументов заданы, то функция сообщает разрешена ли обработка SSL для 
      данного URL и пользователя.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;en=hc.ssl_handling_enabled('https://mail.ru', 
      'Boss')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>enable_user</STRONG></TD>
    <TD>
      <P>Функция позволяет разрешить или запретить пользователю доступ к 
      HandyCache.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      пользователя;<BR><STRONG><EM>enable</EM>&nbsp;-</STRONG> разрешение 
      пользователю с именем <EM><STRONG>name</STRONG></EM> доступа к HandyCache, 
      принимает значения <EM>true</EM> или <EM>false</EM>; если этот аргумент 
      пропущен, то эта функция не изменяет возможность доступа пользователя.</P>
      <P><U>Возвращаемое значение:</U>&nbsp;<EM>true</EM>, если пользователю 
      разрешен доступ, и -&nbsp;<EM>false</EM>, если доступ запрещен;</P>
      <P><U>Пример использования:</U><EM>&nbsp;hc.enable_user('Boss', 
      true)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_users_stat</STRONG></TD>
    <TD>
      <P>Функция позволяет получить информацию о пользователях.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>type</STRONG>&nbsp;-</EM>&nbsp;аргумент 
      функции, от значения которого зависит характер возвращаемой инфлрмации; 
      если этому аргументу присвоить значение '<EM>#all</EM>', то функция вернет 
      таблицу, содержащую информацию о всех пользователях; если этому аргументу 
      присвоить значение '<EM>#active</EM>', то функция вернет таблицу, 
      содержащую информацию об активных пользователях (активными считаются 
      пользователи, имеющие на данный момент хотя бы одно активное соединение с 
      HandyCache); если этому аргументу присвоить имя пользователя, то функция 
      вернет таблицу, содержащую информацию о заданном пользователе;&nbsp; если 
      пользователя с заданным именем нет, то функция вернет <EM>nil;</EM> </P>
      <P><U>Возвращаемое значение:</U> Таблица с информацией о пользователях; 
      каждый элемент возвращаемой таблицы имеет следующие поля: 
      '<EM>from_internet</EM>', '<EM>from_cache</EM>', '<EM>to_internet</EM>', 
      '<EM>connections_number</EM>', '<EM>speed_limit</EM> ';</P>
      <P><U>Пример использования:</U><BR><EM>local t= 
      hc.get_users_stat('Иванов')<BR>if t then cn=t['Иванов'].connections_number 
      end</EM></P></TD></TR>
  <TR>
    <TD><STRONG>set_user_speed</STRONG></TD>
    <TD>
      <P>Функция позволяет задать ограничение скорости загрузки для 
      пользователя.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      пользователя;<BR><STRONG><EM>speed</EM>&nbsp;-</STRONG> лимит скорости для 
      пользователя с именем <STRONG><EM>name </EM></STRONG>в&nbsp;байтах в 
      секунду; если этот аргумент равен нулю, то скорость загрузки&nbsp;не 
      ограничена; если этот аргумент пропущен или он равен <EM>nil</EM> , то эта 
      функция не изменяет лимит скорости загрузки пользователя.</P>
      <P><U>Возвращаемое значение:</U> лимит скорости загрузки пользователя; 
      если скорость загрузки пользователя не ограничена, то возвращается ноль; 
      если пользователь с именем <EM><STRONG>name</STRONG></EM> не найден, то 
      возвращается <EM>nil</EM>;</P>
      <P><U>Пример использования:</U><EM>&nbsp;hc.set_user_speed('Boss', 
      0)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>prepare_path</STRONG></TD>
    <TD>
      <P>Функция создает каталоги в соответсвии с путем, заданным 
аргументом.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>path</STRONG> -</EM> путь к 
      папке;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM> hc.prepare_path('c:\\program 
      files\\handycache\\cache\\example\\')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_dir_files_list</STRONG></TD>
    <TD>
      <P>Функция позволяет получить список файлов у указанном каталоге.</P>
      <P><U>Аргументы функции:
      </U><BR><EM><STRONG>dir</STRONG>&nbsp;-</EM>&nbsp;путь к каталогу, для 
      которого нужно получить список файлов</P>
      <P><U>Возвращаемое значение:</U> Таблица со списком файлов, индекс таблицы от 0.</P>
      <P><U>Пример использования:</U><BR><EM>
      local t= hc.get_dir_files_list('d:\\tmp\\')<BR>
      local i<BR>
      for i=0, #t do<BR>
      &nbsp;&nbsp;hc.put_to_log(t[i])<BR>
      end</EM></P></TD></TR>
  <TR>
    <TD><STRONG>repeat_options</STRONG></TD>
    <TD>
      <P>Функция задает опции, управляющие процессом получения данных от 
      удаленного сервера.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>type</STRONG> 
      -</EM>&nbsp;строка, может принимать значение <EM>'connect'</EM>, 
      <EM>'request'</EM> или <EM>'no_answer'.</EM> 
      <BR><EM><STRONG>time</STRONG>&nbsp;-</EM> если первому аргументу присвоено 
      значение <EM>'connect'</EM>, то второй аргумент задает время на повторные 
      соединения при ошибке в секундах; если первому аргументу присвоено 
      значение <EM>'request'</EM>, то второй аргумент задает время на повторные 
      запросы при ошибке в секундах; если первому аргументу присвоено значение 
      <EM>'no_answer'</EM>, то второй аргумент задает время на повторные запросы 
      без ответа в секундах; если втрому аргументу присвоен nil, то действует 
      время, установленное в настройках на вкладке Управление 
      загрузкой;<BR><EM><STRONG>pause</STRONG>&nbsp;-</EM> если первому 
      аргументу присвоено значение <EM>'connect'</EM> , то&nbsp;третий аргумент 
      задает паузу между попытками повторных соединений при ошибке в секундах; 
      если первому аргументу присвоено значение <EM>'request'</EM>, то третий 
      аргумент задает паузу между повторными попытками запросов при ошибке в 
      секундах; если первому аргументу присвоено значение <EM>'no_answer'</EM>, 
      то третий аргумент задает паузу между повторными попытками запросов без 
      ответа в секундах; если третьему аргументу присвоен nil, то действует 
      пауза, установленная в настройках на вкладке Управление загрузкой;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U> <EM>hc.repeat_options('connect', 30, 
      3)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>call_me_for</STRONG></TD>
    <TD>
      <P>Функция регистрирует функцию текущего расширения в качестве обработчика 
      события для текущего запроса.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>event</STRONG>&nbsp;-</EM> 
      наименование события;<BR><EM><STRONG>function</STRONG>&nbsp;-</EM> имя 
      функции текущего расширения;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM> hc.call_me_for('BeforeAnswerBodySend', 
      'body')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>client_disconnect</STRONG></TD>
    <TD>
      <P>Разрывает заданное соединение с клиентом.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>ind</STRONG>&nbsp;-</EM>&nbsp;номер 
      соединения<EM>.</EM> Если аргумент не задан, то разрывается соединение, в 
      котором работает расширение.</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM> 
      hc.client_disconnect(123)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>server_disconnect</STRONG></TD>
    <TD>
      <P>Разрывает соединение с сервером.</P>
      <P><U>Аргументы функции:</U> Нет.</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM> hc.server_disconnect()</EM></P></TD></TR>
  <TR>
    <TD><STRONG>user_disconnect</STRONG></TD>
    <TD>
      <P>Функция разрывает все установленные на данный момент соединения 
      заданного пользователя.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      пользователя;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM> 
    hc.user_disconnect('Иванов')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>prepare_url</STRONG></TD>
    <TD>
      <P>Функция выполняет преобразование заданного URL в имя файла в кэше без 
      вызова обработчика события URLToFileNameConverting.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>url</STRONG>&nbsp;-</EM>&nbsp;ссылка на 
      сетевой ресурс;<BR><STRONG><EM>URLTransformingList</EM> -</STRONG> 
      разрешение использования списка Преобразование URL при исполнении функции, 
      принимает значения <EM>true</EM> или <EM>false</EM> (по умолчанию 
      <EM>true</EM> ).<BR>
      <STRONG><EM>DecodePunyCode</EM></STRONG> - 
      управление&nbsp;декодированием&nbsp;puny-кода в URL, принимает значения 
      <EM>true</EM> или <EM>false. </EM>Если этот аргумент не задан, то 
      декодирование зависит от&nbsp;состояния опции Декодировать puny-код в 
      URL.<BR>
      <STRONG><EM>DecodeLocaleURL</EM></STRONG> - 
      управление&nbsp;декодированием URL&nbsp;на язык локали, принимает значения 
      <EM>true</EM> или <EM>false. </EM>Если этот аргумент не задан, то 
      декодирование зависит от состояния опции Декодировать&nbsp;URL на язык 
      локали Windows.</P>
      <P><U>Возвращаемое значение:</U> Имя файла в кэше, полученное из заданного 
      URL с помощью встроенного алгоритма преобразования;</P>
      <P><U>Пример использования:</U><EM>&nbsp;local s= 
      hc.prepare_url(hc.url)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>preform_cache_file_name</STRONG></TD>
    <TD>
      <P>Функция задает имя файла в кэше, которое может быть сформировано 
      расширением в обработчике события URLToFileNameConverting. HandyCache, 
      если потребуется, может изменить заданное имя файла для его адаптации к 
      текущему состоянию кэша. Путь к файлу может быть задан абсолютным 
      (начинается с имени диска) или относительным. Во втором случае в начало 
      имени добавляется путь к папке кэша.</P>
      <P><EM>Замечание.</EM> По умолчанию HandyCache не использует файлы вне 
      папки кэша. Чтобы разрешить использование файлов вне папки кэша, нужно в 
      файл HandyCache.ini в секции MainForm добавить строку 
      ReadOnlyFromCachePath=False</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>path</STRONG> -</EM> путь к 
      файлу;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;hc.preform_cache_file_name('site1.ru\example.jpg')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_cache_file_name</STRONG></TD>
    <TD>
      <P>Функция получает имя файла в кэше и его наличие для заданного URL.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>url</STRONG>&nbsp;-</EM>&nbsp;ссылка на 
      сетевой ресурс;</P>
      <P><U>Возвращаемое значение:</U> <STRONG>Первым</STRONG> значением 
      возвращается имя файла; <STRONG>вторым</STRONG> -&nbsp;наличие файла в 
      кэше (<EM>true/false</EM> );</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;s,e=hc.get_cache_file_name('http://handycache.ru/')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_cache_file_size</STRONG></TD>
    <TD>
      <P>Функция получает&nbsp;размер файла в кэше.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;полное имя 
      файла;</P>
      <P><U>Возвращаемое значение:</U> Размер данных в файле за вычетом 
      служебной информации, расположенной в конце файла; если файл не найден, 
      возвращается значение -1.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;len=hc.get_cache_file_size('c:\cache\site.ru\img\qqq.jpg')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_cache_file_age</STRONG></TD>
    <TD>
      <P>Функция получает&nbsp;возраст файла в кэше.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;полное имя 
      файла;</P>
      <P><U>Возвращаемое значение:</U> Время в секундах, прощедшее с момента 
      последнего&nbsp;изменения файла;</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;age=hc.get_cache_file_age('c:\cache\site.ru\img\qqq.jpg')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_cache_file_content_type</STRONG></TD>
    <TD>
      <P>Функция получает&nbsp;тип данных и способ кодирования данных 
      в&nbsp;файле в кэше.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;полное имя 
      файла;</P>
      <P><U>Возвращаемое значение:</U> Первым значением возвращается строка, 
      содержащая тип данных в файле в формате 
      поля&nbsp;Content-Type&nbsp;http-заголовков;&nbsp;вторым 
      значением&nbsp;возвращается строка, содержащая&nbsp;способ кодирования 
      данных в файле в формате 
      поля&nbsp;Content-Encoding&nbsp;http-заголовков;</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;type,encoding=hc.get_cache_file_content_type([[c:\cache\site.ru\img\qqq.jpg]])</EM></P></TD></TR>
  <TR>
    <TD><STRONG>delete_cache_file</STRONG></TD>
    <TD>
      <P>Функция удаляет файл в кэше, соответствующий заданному URL.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>url</STRONG>&nbsp;-</EM>&nbsp;ссылка на 
      сетевой ресурс;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;hc.delete_cache_file([[http://site.ru/example.gif]])</EM></P></TD></TR>
  <TR>
    <TD><STRONG>delete_file</STRONG></TD>
    <TD>
      <P>Функция удаляет файл или каталог вместе с файлами, находящимися в 
      указанном каталоге. В имени файла можно задавать маску с использованием 
      символов '?' и&nbsp;'*'.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;путь 
      к&nbsp;файлу или каталогу;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;hc.delete_file([[c:\cache\site.ru\*.gif]])</EM></P></TD></TR>
  <TR>
    <TD><STRONG>file_last_modified_time</STRONG></TD>
    <TD>
      <P>Функция получает время последнего изменения файла.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>name</STRONG> -</EM> полное имя 
      файла;<BR><EM><STRONG>gmt</STRONG> -</EM> формат представления времени, 
      принимает значения <EM>true</EM> или <EM>false</EM> (по умолчанию 
      <EM>false.</EM>) Если передано значение <EM>true</EM>, то на выходе 
      функции время будет по Гринвичу. Если передано значение <EM>false</EM>, то 
      на выходе функции будет локальное время.</P>
      <P><U>Возвращаемое значение:</U> время последнего изменения файла в 
      числовом представлении.</P>
      <P><U>Пример использования:</U><BR><EM>local 
      tm=hc.file_last_modified_time([[c:\autoexec.bat]])<BR>hc.put_to_log(hc.systime_to_str(tm))</EM></P></TD></TR>
  <TR>
    <TD><STRONG>update_url_info</STRONG></TD>
    <TD>
      <P>Функция удаляет информацию о заданном файле из RAM-кэша и очищает 
      внутренние переменные HandyCache, хранящие информацию об этом файле. Если 
      информация о файле понадобится, она будет добываться из дискового кэша 
      заново.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>url</STRONG>&nbsp;-</EM>&nbsp;ссылка на 
      сетевой ресурс;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;hc.update_url_info('http://handycache.ru/')</EM></P></TD></TR>
  <TR></TR>
  <TR>
    <TD><STRONG>set_global</STRONG></TD>
    <TD>
      <P>Функция позволяет сохранить в памяти значение глобальной переменной. 
      Сразу после завершения работы этой функции присвоенное значение будет 
      доступно из других потоков.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя переменной, 
      которой нужно присвоить значение&nbsp;<EM>value</EM>&nbsp;(если такой 
      переменной нет, она будет 
      создана);<BR><EM><STRONG>value</STRONG>&nbsp;-</EM> значение, которое 
      нужно присвоить глобальной переменной (тип значения - любой доступный в 
      <EM>lua</EM> кроме функции); если этот аргумент пропущен или <EM>nil</EM>, 
      то переменная с именем <EM>name</EM> будет удалена из памяти;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM> hc.set_global('MyVar', 
      'Value')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_global</STRONG></TD>
    <TD>
      <P>Функция позволяет получить значение глобальной переменной.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя переменной, 
      значение которой нужно получить;</P>
      <P><U>Возвращаемое значение:</U>&nbsp;Значение переменной <EM>name.</EM> 
      Если переменной с заданным именем нет, то возвращается <EM>nil.</EM></P>
      <P><U>Пример использования:<BR></U><EM>local 
      t1={}<BR>t1[1]=1<BR>t1['item1']='first item'<BR>local 
      t2={}<BR>t2[1]=11<BR>t2[2]=22<BR>t2[3]=t1<BR>hc.set_global('var1', 
      t2)<BR>local 
      t=hc.get_global('var1')<BR>hc.put_to_log(t[3]['item1'])</EM></P></TD></TR>
  <TR>
    <TD><STRONG>exists_global</STRONG></TD>
    <TD>
      <P>Функция позволяет&nbsp;выяснить имеется ли в памяти&nbsp;глобальная 
      переменная.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      переменной,&nbsp;наличие в памяти&nbsp;которой нужно получить;</P>
      <P><U>Возвращаемое значение:</U>&nbsp;Если переменная с заданным именем существует, то 
      возвращается <EM>true</EM>, в противном случае - <EM>nil.</EM></P>
      <P><U>Пример использования:</U> <EM>if 
      hc.exists_global('var1') then a=hc.get_global('var1') end</EM></P></TD></TR>
  <TR>
    <TD><STRONG>remove_global</STRONG></TD>
    <TD>
      <P>Функция позволяет&nbsp;удалить глобальную переменную.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      переменной,&nbsp;которую надо удалить;</P>
      <P><U>Возвращаемое значение:</U>&nbsp;Нет<EM>.</EM></P>
      <P><U>Пример использования:</U> <EM>if hc.exists_global('var1') then 
      a=hc.remove_global('var1') end</EM></P></TD></TR>
  <TR>
    <TD><STRONG>set_global_table_item</STRONG></TD>
    <TD>
      <P>Функция позволяет сохранить значение в глобальной таблице. Сразу после 
      завершения работы этой функции присвоенное значение будет доступно из 
      других потоков.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>table_name</STRONG>&nbsp;-</EM>&nbsp;имя 
      глобальной таблицы&nbsp;(если такой таблицы нет, она будет создана); если 
      <EM>table_name -</EM> единственный аргумент функции, то таблица с этим 
      именем будет 
      удалена;<BR><EM><STRONG>index_list</STRONG>&nbsp;-</EM>&nbsp;список 
      индексов&nbsp;элемента глобальной таблицы (если такого элемента таблицы 
      нет, то он будет создан); список может быть произвольной длины, значения 
      списка индексов могут принимать цифровые или строковые значения; например, 
      если в списке два значения, то это означает, что в&nbsp;глобальную таблицу 
      вложена другая таблица; первое значение списка индексов задает индекс в 
      глобальной таблице, 
      второй элемент списка индексов задает индекс элемента во вложенной 
      таблице;<BR><EM><STRONG>value</STRONG>&nbsp;-</EM> значение, которое нужно 
      присвоить элементу глобальной таблицы (тип значения - любой доступный в 
      <EM>lua</EM> кроме функции); если этот аргумент пропущен или <EM>nil</EM>, 
      то элемент таблицы с именем <EM>item_name</EM> будет удален из памяти;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM> hc.set_global_table_item('MyTable', 
      'Index1',&nbsp;</EM><EM>'Index2',&nbsp;</EM><EM>'Value')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>get_global_table_item</STRONG></TD>
    <TD>
      <P>Функция позволяет получить значение элемента глобальной таблицы.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>table_name</STRONG>&nbsp;-</EM> &nbsp;имя 
      глобальной таблицы;<BR><EM><STRONG>index_list</STRONG>&nbsp;-</EM>&nbsp;&nbsp;список 
      индексов&nbsp;элемента глобальной таблицы; список может быть произвольной 
      длины, значения списка индексов могут принимать цифровые или строковые 
      значения; например, если в списке два значения, то это означает, что 
      в&nbsp;глобальную таблицу вложена другая таблица; первое значение списка 
      индексов задает индекс в глобальной таблице, второй элемент списка 
      индексов задает индекс 
      элемента во вложенной таблице;</P>
      <P><U>Возвращаемое значение:</U>&nbsp;Значение&nbsp; элемента глобальной 
      таблицы <EM>item_name.</EM> Если элемента глобальной таблицы с заданным 
      именем нет, то возвращается <EM>nil.</EM></P>
      <P><U>Пример использования:<BR></U><EM>local 
      t1={}<BR>t1[1]=1<BR>t1['item1']='first item'<BR>local 
      t2={}<BR>t2[1]=11<BR>t2[2]=22<BR>t2[3]=t1<BR>hc.set_global('var1', 
      t2)<BR>local t= 
      hc.get_global_table_item('var1',3)<BR>hc.put_to_log(t['item1'])</EM></P></TD></TR>
  <TR>
    <TD><STRONG>exists_global_table_item</STRONG></TD>
    <TD>
      <P>Функция позволяет&nbsp;выяснить имеется ли в памяти&nbsp;значение 
      элемента глобальной таблицы.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>table_name</STRONG>&nbsp;-</EM> &nbsp;имя 
      глобальной таблицы;<BR><EM><STRONG>index_list</STRONG>&nbsp;-</EM>&nbsp;&nbsp;список 
      индексов&nbsp;элемента глобальной таблицы; список может быть произвольной 
      длины, значения списка индексов могут принимать цифровые или строковые 
      значения; например, если в списке два значения, то это означает, что 
      в&nbsp;глобальную таблицу вложена другая таблица; первое значение списка 
      индексов задает индекс в глобальной таблице, второй элемент списка 
      индексов задает индекс элемента 
      во вложенной таблице;</P>
      <P><U>Возвращаемое значение:</U>&nbsp;Если значение 
      элемента&nbsp;глобальной таблицы&nbsp;с заданным именем существует, то 
      возвращается <EM>true</EM>, в противном случае - <EM>nil.</EM></P>
      <P><U>Пример использования:</U> 
      <EM>if hc.exists_global_table_item('var1',3,'a') then 
      a=hc.get_global_table_item('var1',3</EM><EM>,'a'</EM><EM>) 
  end</EM></P></TD></TR>
  <TR>
    <TD><STRONG>remove_global_table_item</STRONG></TD>
    <TD>
      <P>    Функция позволяет&nbsp;удалить 
      элемент глобальной таблицы.</P>
      <P><U>Аргументы 
      функции:<BR></U><EM><STRONG>table_name</STRONG>&nbsp;-</EM> &nbsp;имя 
      глобальной таблицы;<BR><EM><STRONG>index_list</STRONG>&nbsp;-</EM>&nbsp;&nbsp;список 
      индексов&nbsp;элемента глобальной таблицы; список может быть произвольной 
      длины, значения списка индексов могут принимать цифровые или строковые 
      значения; например, если в списке два значения, то это означает, что 
      в&nbsp;глобальную таблицу вложена другая таблица; первое значение списка 
      индексов задает индекс в глобальной таблице, второй элемент списка 
      индексов задает индекс элемента 
      во вложенной таблице;</P>
      <P><U>Возвращаемое значение:</U>    &nbsp;Нет <EM>.</EM></P>
      <P><U>Пример использования:</U> 
      <EM>if hc.exists_global_table_item('var1',3,'a') then 
      a=hc.remove_global_table_item('var1',3</EM><EM>,'a'</EM><EM>) 
    end</EM></P></TD></TR>
  <TR>
    <TD><STRONG>window_pos</STRONG></TD>
    <TD>
      <P>Функция получает положение и размер главного окна HandyCache.</P><U>
      <P><U>Аргументы функции:</U> Нет.</P></U>
      <P><U>Возвращаемое значение:</U> <STRONG>Первым</STRONG> значением 
      возвращается горизонтальная координата верхнего левого угла окна; 
      <STRONG>вторым</STRONG> <STRONG>-</STRONG>&nbsp;вертикальная координата 
      верхнего левого угла окна; <STRONG>третьим</STRONG> - ширина окна; 
      <STRONG>четвертым</STRONG> - высота окна;</P>
      <P><U>Пример 
    использования:</U><EM>&nbsp;x,y,w,h=hc.window_pos()</EM></P></TD></TR>
  <TR>
    <TD><STRONG>enable_extension</STRONG></TD>
    <TD>
      <P>Функция позволяет разрешать или запрещать работу расширения с заданным 
      именем.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      расширения;<BR><EM><STRONG>enable</STRONG>&nbsp;-</EM>&nbsp;флаг, 
      разрешающий или запрещающий работу расширения (<EM>true/false</EM>); если 
      этот аргумент опущен, функция не меняет текущее состояние флага;</P>
      <P><U>Возвращаемое значение:</U> Текущее состояние разрешения работы 
      расширения (<EM>true/false.</EM>)</P>
      <P><U>Пример использования:</U><EM> hc.enable_extension('Cache cleaner', 
      true)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>reload_extension</STRONG></TD>
    <TD>
      <P>Функция заставляет HandyCache перечитать файл расширения с заданным 
      именем с последущим вызовом обработчика события Init.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      расширения;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример использования:</U><EM>&nbsp;hc.reload_extension('Cache 
      cleaner')</EM></P></TD></TR></TBODY></TABLE>
<P></P>
<H3 align=center>&nbsp;</H3>
<P align=left>Для выполнения регулярных выражений в HandyCache и расширениях 
используется библиотека PCRE.</P>
<P align=center>PCRE License</P><PRE>PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
           Copyright (c) 1997-2009 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.</PRE>
<P></P>
<H3 align=center><FONT face=Arial>Переменные таблицы re, доступные в 
расширениях</FONT></H3>
<TABLE border=1 cellSpacing=2>
  <TBODY>
  <TR>
    <TD align=center>
      <P><B>Имя</B></P></TD>
    <TD align=center><STRONG>Допустимые действия</STRONG></TD>
    <TD align=center>
      <P><B>События</B></P></TD>
    <TD align=center>
      <P><B>Допустимые значения</B></P></TD>
    <TD align=center>
      <P><B>Описание</B></P></TD></TR>
  <TR>
    <TD><STRONG>engine</STRONG></TD>
    <TD>čtení, zápis</TD>
    <TD>Все события</TD>
    <TD>1..20</TD>
    <TD>
      <P>Расширения могут использовать до двадцати движков, исполняющих 
      регулярные выражения. Значение <EM>engine</EM> позволяет выбрать для 
      использования один из этих движков. Как правило, для выполнения своей 
      работы расширению достаточно одного движка. Если не присвоить значение 
      этой переменной, то по умолчанию будет использоваться первый движок. 
      Однако, если, например, в callout-функции требуется выполнить регулярное 
      выражение, то использовать для этой цели первый движок уже нельзя, это 
      вызовет нарушение работы первого движка после выхода из callout-функции. 
      Для использования в callout-функции нужно использовать другой движок. В 
      callout-функции следует перед выполнением регулярных выражений включить 
      другой движок присвоив переменной <EM>engine</EM> значение отличное от 
      единицы, а потом вернуть расширение к использованию первого движка.</P>
      <P>Прочитав значение этой переменной расширение может узнать номер 
      текущего движка.</P></TD></TR>
   <TR>
    <TD><STRONG>info_options</STRONG></TD>
    <TD>čtení</TD>
    <TD>Все события</TD>
    <TD>&nbsp;</TD>
    <TD>
      <P>Получает&nbsp;опции, с которыми было скомпилировано,&nbsp;регулярное 
      выражение.</P>
      <P> Опции, с которыми было скомпилировано, 
      регулярное выражение. Значения опций представлены битовой 
      маской:<BR>PCRE_CASELESS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000001<BR>PCRE_MULTILINE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
      0x00000002<BR>PCRE_DOTALL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000004<BR>PCRE_EXTENDED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000008<BR>PCRE_ANCHORED&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000010<BR>PCRE_DOLLAR_ENDONLY&nbsp; &nbsp;&nbsp; 
      0x00000020<BR>PCRE_EXTRA&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
      0x00000040<BR>PCRE_NOTBOL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000080<BR>PCRE_NOTEOL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000100<BR>PCRE_UNGREEDY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000200<BR>PCRE_NOTEMPTY&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00000400<BR>PCRE_UTF8&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
      &nbsp;&nbsp; 0x00000800<BR>PCRE_NO_AUTO_CAPTURE&nbsp; &nbsp; 
      0x00001000<BR>PCRE_NO_UTF8_CHECK&nbsp; &nbsp; &nbsp; 
      0x00002000<BR>PCRE_AUTO_CALLOUT&nbsp; &nbsp; &nbsp;&nbsp; 
      0x00004000<BR>PCRE_PARTIAL_SOFT&nbsp; &nbsp; &nbsp;&nbsp; 
      0x00008000<BR>PCRE_DFA_SHORTEST&nbsp; &nbsp; &nbsp;&nbsp; 
      0x00010000<BR>PCRE_DFA_RESTART&nbsp; &nbsp; &nbsp; &nbsp; 
      0x00020000<BR>PCRE_FIRSTLINE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
      0x00040000<BR>PCRE_DUPNAMES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00080000<BR>PCRE_NEWLINE_CR&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00100000<BR>PCRE_NEWLINE_LF&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 
      0x00200000<BR>PCRE_NEWLINE_CRLF&nbsp; &nbsp; &nbsp;&nbsp; 
      0x00300000<BR>PCRE_NEWLINE_ANY&nbsp; &nbsp; &nbsp; &nbsp; 
      0x00400000<BR>PCRE_NEWLINE_ANYCRLF&nbsp; &nbsp; 
      0x00500000<BR>PCRE_BSR_ANYCRLF&nbsp; &nbsp; &nbsp; &nbsp; 
      0x00800000<BR>PCRE_BSR_UNICODE&nbsp; &nbsp; &nbsp; &nbsp; 
      0x01000000<BR>PCRE_JAVASCRIPT_COMPAT&nbsp; 
      0x02000000<BR>PCRE_NO_START_OPTIMIZE&nbsp; 
      0x04000000<BR>PCRE_PARTIAL_HARD&nbsp; &nbsp; &nbsp;&nbsp; 
      0x08000000<BR>PCRE_NOTEMPTY_ATSTART&nbsp;&nbsp; 
      0x10000000<BR>PCRE_UCP&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
      &nbsp; 0x20000000</P>
      <P><U>Пример использования:</U><EM> local opt=                   
    re.info_options</EM></P></TD>
</TR>
   <TR>
    <TD><STRONG>info_maxlookbehind</STRONG></TD>
    <TD>čtení</TD>
    <TD>Все события</TD>
    <TD>&nbsp;</TD>
    <TD>
      <P>Выдает количество символов в самом длинном lookbehind assertion 
      последнего регулярного выражения. Эта информация полезна при организации 
      поиска по регулярному выражению в условиях неполноты (поступления по 
      частям) анализируемой строки.</P>
      <P><U>Пример использования:</U><EM> local max_len= 
      re.info_maxlookbehind</EM></P></TD>
</TR>
   <TR>
    <TD><STRONG>info_jit</STRONG></TD>
    <TD>čtení</TD>
    <TD>Все события</TD>
    <TD>&nbsp;</TD>
    <TD>
      <P>Получает значение&nbsp;1, если регулярное выражение было скомпилировано 
      с опцией PCRE_STUDY_JIT_COMPILE и jit-компиляция завершилась успешно. 
      Возвращает 0, если использовние jit по каким-то причинам оказалось 
      невозможным.</P>
      <P><U>Пример использования:</U><EM> local jit=                   
  re.info_jit</EM></P></TD>
</TR>
</TBODY>
</TABLE>
<PRE></PRE><PRE><H3 align=center><FONT size=2 face=Arial><FONT size=4>Функции таблицы re для работы с регулярными выражениями</FONT></FONT></H3></PRE>
<P align=left>
<TABLE border=1 cellSpacing=2>
  <TBODY>
  <TR>
    <TD>
      <P align=center><STRONG>Имя</STRONG></P></TD>
    <TD>
      <P align=center><STRONG>Описание</STRONG></P></TD></TR>
  <TR>
    <TD><STRONG>select_engine</STRONG></TD>
    <TD>
      <P>Эта функция делает то же действие, что и присвоение значения 
      переменной&nbsp;<EM>engine </EM>(функция оставлена для сохранения 
      совместимости со старыми версия расширений). C помощью этой функции можно 
      выбрать какой из имеющихся движков будет использоваться.</P>
      <P><U>Аргументы функции:</U><BR><EM><STRONG>num</STRONG>&nbsp;-</EM> 
      &nbsp;номер движка, может принимать значения от 1 до&nbsp;20;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:<BR></U><EM>re.select_engine(2)<BR>s=re.replace(hc.answer_header, 
      [[(?-s)(Cache-Control:.*\r\n)]],nil)<BR>re.select_engine(1)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>set_regex</STRONG></TD>
    <TD>
      <P>Задает регулярное выражение.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>regex</STRONG>&nbsp;-</EM>&nbsp;регулярное 
      выражение;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;re.set_regex([[(.*\.).*]])</EM></P></TD></TR>
  <TR>
    <TD><STRONG>set_subj</STRONG></TD>
    <TD>
      <P>Задает строку, над которой буде исполняться регулярное выражение.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>subj</STRONG>&nbsp;-</EM>&nbsp;строка;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;re.set_subj(hc.answer_header)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>set_callout</STRONG></TD>
    <TD>
      <P>Задает имя callout-функции.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>func</STRONG>&nbsp;-</EM>&nbsp;имя 
      callout-функции;</P>
      <P><U>Возвращаемое значение:</U> Нет.</P>
      <P><U>Пример 
      использования:</U><EM>&nbsp;re.set_callout('callout_func')</EM></P></TD></TR>
  <TR>
    <TD><STRONG>match</STRONG></TD>
    <TD>
      <P>Вызывает исполнение регулярного выражения.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>subj</STRONG>&nbsp;-</EM>&nbsp;строка, над 
      которой будет исполняться регулярное выражение; если на месте этого 
      аргумента задан <EM>nil </EM>или этот аргумент опущен, то будет 
      использоваться subj-строка, заданная предыдущей 
      функцией.<BR><EM><STRONG>regex</STRONG> -</EM> регулярное выражение; если 
      на месте этого аргумента задан <EM>nil </EM>или этот аргумент опущен, то 
      будет использоваться регулярное выражение, заданное предыдущей 
      функцией;<BR><EM><STRONG>offset</STRONG> -</EM> смещение позиции в 
      <EM>subj</EM>-строке, с которой начнется исполнение регулярного выражения; 
      если на месте этого аргумента задан <EM>nil </EM>или этот аргумент опущен, 
      то исполнение регулярного выражения начнется с начала строки (1-й 
      позиции);<BR><EM><STRONG>partial</STRONG> -</EM> флаг, разрешающий 
      использовать частичное совпадение; может принимать 
      значение&nbsp;<EM>'soft'</EM> или <EM>'hard'</EM>;&nbsp;для совместимости 
      со старыми версиями может принимать значение <EM>true </EM>(равносильно 
      значению <EM>'soft'</EM> ); если на месте этого аргумента задан <EM>nil 
      </EM>или этот аргумент опущен, то частичные совпадения не 
используются;</P>
      <P><U>Возвращаемое значение:</U> Если в результате исполнения регулярного 
      выражения найдена хотя бы одна подстрока, то <STRONG>первым</STRONG> 
      значением функция возвращает таблицу;&nbsp;в&nbsp;таблице будет ровно 
      столько элементов, сколько нужно для размещения значений для всех 
      найденных подстрок (например, если номер последней найденной подстроки 
      равен два, то в таблице будет три элемента с индексами 0, 1 и 2);&nbsp;в 
      этой таблице для каждой&nbsp;подстроки находится по паре значений: 
      begin_pos и end_pos; эти значения задают соответственно позиции в 
      <EM>subj</EM>-строке для начала и конца каждой&nbsp;подстроки; 
      если&nbsp;подстрока не была найдена, то для нее будут записаны значения 
      begin_pos и end_pos равные <EM>-1</EM>;&nbsp;&nbsp;если в результате 
      исполнения регулярного выражения не найдено ни одной подстроки, то 
      <STRONG>первому</STRONG> возвращаемому значению присваивается 
      <EM>nil</EM>, а в качестве <STRONG>второго</STRONG> значения возвращается 
      строка с описанием ошибки; в качестве <STRONG>третьего</STRONG> значения 
      функции всегда выводится значение (*Mark).</P>
      <P><U>Пример использования:<BR></U><EM>local t=re.match(s, regex)<BR>if t 
      then hc.put_to_log('длина подстроки='..t[0].end_pos-t[0].begin_pos+1) 
      end</EM></P></TD></TR>
  <TR>
    <TD><STRONG>substr_count</STRONG></TD>
    <TD>
      <P>Получает&nbsp;номер последней подстроки, найденной в результате 
      последнего исполнения регулярного выражения.</P>
      <P><U>Аргументы функции:</U> Нет.</P>
      <P><U>Возвращаемое значение:</U> Номер последней найденной подстроки.</P>
      <P><U>Пример использования:</U><EM> local num=                                             
    re.substr_count()</EM></P></TD></TR>
  <TR>
    <TD><STRONG>substr</STRONG></TD>
    <TD>
      <P>Получает подстроку с заданным номером, найденную в результате 
      последнего исполнения регулярного выражения.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>num</STRONG>&nbsp;-</EM>&nbsp;номер подстроки 
      (счет начинается с 0);</P>
      <P><U>Возвращаемое значение:</U> Возвращается подстрока; если подстрока с 
      заданным номером не найдена, то возвращается&nbsp;пустая строка;</P>
      <P><U>Пример использования:</U><EM>&nbsp;local 
  s=re.substr(0)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>substr_length</STRONG></TD>
    <TD>
      <P>Получает длину подстроки с заданным номером, найденной в результате 
      последнего исполнения регулярного выражения.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>num</STRONG>&nbsp;-</EM>&nbsp;номер 
      подстроки;</P>
      <P><U>Возвращаемое значение:</U> Возвращается длина подстроки; если 
      подстроки с заданным номером нет, то возвращается значение меньше 
      единицы&nbsp;;</P>
      <P><U>Пример использования:</U><EM>&nbsp;local 
      l=re.substr_length(0)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>substr_offset</STRONG></TD>
    <TD>
      <P>Получает смещение позиции начала подстроки с заданным номером в 
      <EM>subj</EM>-строке, найденной в результате последнего исполнения 
      регулярного выражения.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>num</STRONG>&nbsp;-</EM>&nbsp;номер 
      подстроки;</P>
      <P><U>Возвращаемое значение:</U> Возвращается смещение подстроки; если 
      подстроки с заданным номером нет, то возвращается&nbsp;значение меньше 
      единицы&nbsp;(символы в lua-строке нумеруются начиная с <EM>1</EM>, 
      поэтому&nbsp;значение меньше единицы&nbsp;можно использовать как признак 
      того, что данная подстрока не была найдена); </P>
      <P><U>Пример использования:</U><EM>&nbsp;local 
      offset=re.substr_offset(0)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>named_substr_index</STRONG></TD>
    <TD>
      <P>Получает индекс именованной подстроки, найденной в результате 
      последнего исполнения регулярного выражения.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>name</STRONG>&nbsp;-</EM>&nbsp;имя 
      подстроки;</P>
      <P><U>Возвращаемое значение:</U> Возвращается индекс подстроки с заданным 
      именем; если подстроки с заданным именем нет, то возвращается 
      <EM>-1;</EM></P>
      <P><U>Пример использования:<BR></U><EM>t= re.match(s, 
      'a(?&lt;name&gt;b)')<BR>i=re.named_substr_index('name')<BR>if i&gt;0 then l=   
       t[i].end_pos-t[i].begin_pos</EM></P></TD></TR>
  <TR>
    <TD><STRONG>offsets_vector_size</STRONG></TD>
    <TD>
      <P>Получает размер вектора (массива) результатов выполнения регулярного 
      выражения.</P>
      <P><U>Аргументы функции:</U> Нет.</P>
      <P><U>Возвращаемое значение:</U> Возвращается размер массива 
      результатов;</P>
      <P><U>Пример использования:</U><EM>&nbsp;local 
      n=re.offsets_vector_size()</EM></P></TD></TR>
  <TR>
    <TD><STRONG>offsets_vector</STRONG></TD>
    <TD>
      <P>Получает элемент вектора (массива) результатов выполнения регулярного 
      выражения.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>index</STRONG>&nbsp;-</EM>&nbsp;номер элемента 
      массива;</P>
      <P><U>Возвращаемое значение:</U> Возвращается элемент массива результатов, 
      обычно это смещение от начала строки, с которой работает регулярное 
      выражение; если элемента с заданным номером нет, то возвращается 
      <EM>-1;</EM></P>
      <P><U>Пример использования:</U><EM>&nbsp;local 
      offset=re.offsets_vector(0)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>find</STRONG></TD>
    <TD>
      <P>Получает значение заданной подстроки.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>subj</STRONG>&nbsp;-</EM>&nbsp;строка, над 
      которой будет исполняться регулярное выражение; если на месте этого 
      аргумента задан <EM>nil </EM>или этот аргумент опущен, то будет 
      использоваться строка, заданная предыдущей 
      функцией.<BR><EM><STRONG>regex</STRONG> -</EM> регулярное выражение; если 
      на месте этого аргумента задан <EM>nil </EM>или этот аргумент опущен, то 
      будет использоваться регулярное выражение, заданное предыдущей 
      функцией;<BR><EM><STRONG>num</STRONG> -</EM> &nbsp;номер искомой 
      подстроки; если на месте этого аргумента задан <EM>nil </EM>или этот 
      аргумент опущен, то ищется подстрока с номером 
      0;<BR><EM><STRONG>partial</STRONG> -</EM> флаг, разрешающий использовать 
      частичное совпадение; может принимать значение <EM>'soft'</EM> или 
      <EM>'hard'</EM>; для совместимости со старыми версиями может принимать 
      значение <EM>true</EM>(равносильно значению <EM>'soft'</EM>); если на 
      месте этого аргумента задан <EM>nil </EM>или этот аргумент опущен, то 
      частичные совпадения не используются;</P>
      <P><U>Возвращаемое значение:</U> Если в результате исполнения регулярного 
      выражения найдена подстрока с заданным номером, то <STRONG>первым</STRONG> 
      значением функция возвращает эту подстроку; если не найдена заданная 
      подстрока, то <STRONG>первому</STRONG> возвращаемому значению 
      присваивается <EM>nil;</EM>&nbsp;если при исполнении регулярного выражения 
      не было обнаружено ошибок, то <STRONG>вторым</STRONG> значением функции 
      будет <EM>nil</EM>;&nbsp;если при исполнении регулярного выражения 
      произошла ошибка, то в качестве <STRONG>второго</STRONG> значения 
      возвращается строка с описанием ошибки; в качестве 
      <STRONG>третьего</STRONG> значения функции выводится значение (*Mark).</P>
      <P><U>Пример использования:</U><EM>&nbsp;local s=re.find(hc.answer_header, 
      [[^Content-Length: (.+)]], 1)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>replace</STRONG></TD>
    <TD>
      <P>Заменяет в строке найденные подстроки заданным значением.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>subj</STRONG>&nbsp;-</EM>&nbsp;строка, над 
      которой будет исполняться регулярное выражение и в которой будут 
      заменяться найденные подстроки; если на месте этого аргумента задан 
      <EM>nil </EM>или этот аргумент опущен, то будет использоваться 
      subj-строка, заданная предыдущей функцией.<BR><EM><STRONG>regex</STRONG> 
      -</EM> регулярное выражение; если на месте этого аргумента задан <EM>nil 
      </EM>или этот аргумент опущен, то будет использоваться регулярное 
      выражение, заданное вызовом предыдущей 
      функцией;<BR><EM><STRONG>repl</STRONG> &nbsp;-</EM> строка, которой будут 
      заменяться найденные подстроки; если на месте этого аргумента задан 
      <EM>nil </EM>или этот аргумент опущен, то найденные подстроки будут 
      заменяться пустой строкой (удаляться);<BR><EM><STRONG>all</STRONG> -</EM> 
      флаг, указывающий, что применение регулярного выражения и выполнение 
      замены должно производиться повторно пока будет обнаруживаться совпадение 
      (<EM>true/false</EM> ); если на месте этого аргумента задан <EM>nil 
      </EM>или этот аргумент опущен, то применение регулярного выражения и 
      выполнение замены производится однократно (значение <EM>false</EM> 
      );<BR><EM><STRONG>partial</STRONG> -</EM> флаг, разрешающий использовать 
      частичное совпадение; может принимать значение <EM>'soft'</EM> или 
      <EM>'hard';</EM> для совместимости со старыми версиями может принимать 
      значение <EM>true </EM>(равносильно значению <EM>'soft'</EM>); если на 
      месте этого аргумента задан <EM>nil </EM>или этот аргумент опущен, то 
      частичные совпадения не используются;</P>
      <P><U>Возвращаемое значение:</U> Если при исполнении регулярного выражения 
      не было ошибок (даже если не найдено ни одной подстроки), то 
      <STRONG>первым</STRONG> значением функция возвращает строку - результат 
      обработки (в противном случае <EM>nil</EM>);&nbsp;<STRONG>вторым</STRONG> 
      значением возвращается число произведенных замен; <STRONG>третьим</STRONG> 
      значением функция возвращает позицию в результирующей строке, с которой 
      начинается неизмененная часть; если в результате исполнения регулярного 
      выражения произошла ошибка, то <STRONG>четвертым</STRONG> значением 
      возвращается строка с описанием ошибки.</P>
      <P><U>Пример использования:</U><EM>&nbsp;s=re.replace(hc.answer_header, 
      [[(?-s)(Cache-Control:.*\r\n)]], nil)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>register_regex</STRONG></TD>
    <TD>
      <P>Регистрирует регулярное выражение.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>regex</STRONG>&nbsp;-</EM>&nbsp;регулярное 
      выражение, заданное в этом аргументе, компилируется и результат компиляции 
      сохраняется во внутреннем кэше регулярных выражений HandyCache;</P>
      <P><U>Возвращаемое значение:</U> 
      Возвращается идентификатор зарегистрированного регулярного выражения. В 
      дальнейшем расширения могут использовать этот идентификатор при&nbsp;вызове 
      функций&nbsp;в качестве аргумента вместо самого регулярного выражения; </P>
      <P><U>Пример использования:</U><BR><EM>local reg_id=re.register_regex([[(?-s)(Cache-Control:.*\r\n)]])<BR>
       s=re.replace(hc.answer_header, reg_id, nil)</EM></P></TD></TR>
  <TR>
    <TD><STRONG>registered_regex</STRONG></TD>
    <TD>
      <P>Проверяет заегистрировано&nbsp;регулярное выражение 
      с заданным идентификатором&nbsp;или нет.</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>reg_id</STRONG>&nbsp;-</EM> 
               
          &nbsp;идентификатор регулярного выражения;</P>
      <P><U>Возвращаемое значение:</U> 
            
          true, если регулярное 
      выражение с заданным идентификатором есть в кэше; </P>
      <P><U>Пример использования:</U><BR><EM>local reg=[[(?-s)(Cache-Control:.*\r\n)]]<BR>
      if not 
      re.registered_regex(reg_id)
      then reg_id= re.register_regex(reg) end</EM></P>
  <TR>
    <TD><STRONG>unregister_regex</STRONG></TD>
    <TD>
      <P>Удаляет из кэша&nbsp;регулярное выражение с заданным идентификатором (освобождает память).</P>
      <P><U>Аргументы 
      функции:</U><BR><EM><STRONG>reg_id</STRONG>&nbsp;-</EM>     
       &nbsp;идентификатор регулярного выражения;</P>
      <P><U>Возвращаемое значение:</U>  
          Нет.</P>
      <P><U>Пример использования:</U>&nbsp;<EM> 
       re.unregister_regex(reg_id)</EM></P></TD></TR></TBODY></TABLE></P>
<H3 align=center>Хранение данных, используемых расширениями</H3>
<P>Для исполнения обработчиков событий в каждом потоке-обработчике соединения с 
клиентом создается своя <EM>lua</EM>-машина. Глобальные переменные, создаваемые 
обработчиками в <EM>lua</EM> -машине доступны для всех обработчиков, которые 
будут вызваны позднее в этом потоке.</P>
<P>При загрузке каждого расширения в HandyCache создается пустая таблица 
<EM>hc_static</EM>, привязанная к этому расширению. Следом для каждого 
расширения вызывается обработчик <EM>Init</EM> (если таковой зарегистрирован). 
Он может сохранить значения в таблице <EM>hc_static</EM> и они будут доступны во 
всех обработчиках этого расширения при обработке всех последующих запросов. 
Также обработчик <EM>Options</EM> (вызывается нажатием кнопки <EM>Настройки 
расширения</EM> на вкладке <EM>Расширения</EM> ) может изменить значения в этой 
таблице (или добавить новые) и они будут доступны при обработке всех последующих 
запросов.</P>
<P>Когда создается поток-обработчик запроса клиента, в нем создается копия 
таблицы <EM>hc_static</EM> для каждого расширения и внутри потока работа идет 
уже с этой копией. Обработчики событий могут добавлять/изменять переменные, но 
доступны эти значения будут только внутри этого потока.</P>
<P>Обработчики событий при необходимости могут сохранять значения в глобальных 
переменных. Значения, сохраненные в глобальных переменных, с момента присвоения 
и до завершения работы программы становятся доступны из всех обработчиков всех 
потоков. Для доступа к глобальным переменным используются функции 
<EM>hc.set_global</EM> и <EM>hc.get_global.</EM></P>
<H3 align=center>Графический интерфейс пользователя</H3>
<P>Расширения HandyCache как и другие программы на <EM>lua</EM> могут 
использовать графический интерфейс пользователя. Вот несколько примеров 
предназначенных для таких целей библиотек: <A 
href="http://wxlua.sourceforge.net/">wxlua</A>, <A 
href="http://luaforge.net/projects/luainterface">LuaInterface</A>, <A 
href="http://vclua.luaforge.net/">VCLua</A>. Мне наиболее подходящей для 
расширений HandyCache показалась библиотека VCLua (сравнительно просто 
использовать, малый размер dll). Пример использования этой библиотеки в 
обработчике события <EM>Options</EM> можно найти в расширении 
<EM>eCacheCleaner</EM> (для использования этой библиотеки в папке HandyCache 
должен находиться файл <EM>vcl.dll</EM>).</P>
<H3 align=center>Тестирование расширений</H3>
<P>В файле <EM>LuaTest.exe</EM> находится программа для тестирования работы 
расширений. Для тестирования расширения загрузите его в эту программу и нажмите 
кнопку <EM>Перечитать.</EM> В появившемся ниже списке обработчиков событий 
выберите интерисующий и нажмите кнопку <EM>Выполнить (F5)</EM> для вызова 
выделенной функции-обработчика. Чтобы выполнить функцию, отсутствующую в списке, 
впишите ее имя в поле ввода рядом с кнопкой <EM>Выполнить</EM> и нажмите эту 
кнопку.</P>
<P>Информацию о языке <EM>lua</EM> можно найти, например, здесь: <NOINDEX><A 
href="http://www.lua.org/manual/5.1/" rel=nofollow>по-английски</A> или <A 
href="http://www.lua.ru/doc/" rel=nofollow>по-русски</A>.</P></BODY></HTML>
